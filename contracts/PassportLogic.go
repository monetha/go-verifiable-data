// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contracts

import (
	"fmt"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// PassportLogicContractABI is the input ABI used to generate the binding from.
const PassportLogicContractABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeIdx\",\"type\":\"uint256\"}],\"name\":\"finishPrivateDataExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeIdx\",\"type\":\"uint256\"}],\"name\":\"timeoutPrivateDataExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateDataExchangeAcceptTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getTxDataBlockNumber\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAllowedFactProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getIPFSHash\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteIPFSHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_onlyWhitelist\",\"type\":\"bool\"}],\"name\":\"setWhitelistOnlyPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteBool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getPrivateDataHashes\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"dataIPFSHash\",\"type\":\"string\"},{\"name\":\"dataKeyHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"bytes\"}],\"name\":\"setBytes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"int256\"}],\"name\":\"setInt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"setTxDataBlockNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteBytes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isWhitelistOnlyPermissionSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deletePrivateDataHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getBytes\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setIPFSHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFactProviderFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"string\"}],\"name\":\"setString\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"privateDataExchanges\",\"outputs\":[{\"name\":\"dataRequester\",\"type\":\"address\"},{\"name\":\"dataRequesterValue\",\"type\":\"uint256\"},{\"name\":\"passportOwner\",\"type\":\"address\"},{\"name\":\"passportOwnerValue\",\"type\":\"uint256\"},{\"name\":\"factProvider\",\"type\":\"address\"},{\"name\":\"key\",\"type\":\"bytes32\"},{\"name\":\"dataIPFSHash\",\"type\":\"string\"},{\"name\":\"dataKeyHash\",\"type\":\"bytes32\"},{\"name\":\"encryptedExchangeKey\",\"type\":\"bytes\"},{\"name\":\"exchangeKeyHash\",\"type\":\"bytes32\"},{\"name\":\"encryptedDataKey\",\"type\":\"bytes32\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"stateExpired\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getUint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrivateDataExchangesCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeIdx\",\"type\":\"uint256\"},{\"name\":\"_encryptedDataKey\",\"type\":\"bytes32\"}],\"name\":\"acceptPrivateDataExchange\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isFactProviderInWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteInt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getInt\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getBool\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteTxDataBlockNumber\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"privateDataExchangeProposeTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setBool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addFactProviderToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openPrivateDataExchangesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_encryptedExchangeKey\",\"type\":\"bytes\"},{\"name\":\"_exchangeKeyHash\",\"type\":\"bytes32\"}],\"name\":\"proposePrivateDataExchange\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setUint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteUint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_factProvider\",\"type\":\"address\"},{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"getString\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"value\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"},{\"name\":\"_dataIPFSHash\",\"type\":\"string\"},{\"name\":\"_dataKeyHash\",\"type\":\"bytes32\"}],\"name\":\"setPrivateDataHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_key\",\"type\":\"bytes32\"}],\"name\":\"deleteString\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeIdx\",\"type\":\"uint256\"},{\"name\":\"_exchangeKey\",\"type\":\"bytes32\"}],\"name\":\"disputePrivateDataExchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"PrivateDataHashesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"PrivateDataHashesDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exchangeIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"dataRequester\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"passportOwner\",\"type\":\"address\"}],\"name\":\"PrivateDataExchangeProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exchangeIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"dataRequester\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"passportOwner\",\"type\":\"address\"}],\"name\":\"PrivateDataExchangeAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exchangeIdx\",\"type\":\"uint256\"}],\"name\":\"PrivateDataExchangeClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exchangeIdx\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"successful\",\"type\":\"bool\"},{\"indexed\":true,\"name\":\"cheater\",\"type\":\"address\"}],\"name\":\"PrivateDataExchangeDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"IPFSHashUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"IPFSHashDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"TxDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"TxDataDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"BytesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"BytesDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"StringUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"StringDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"BoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"BoolDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"IntUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"IntDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"UintUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"UintDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"AddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"AddressDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"onlyWhitelist\",\"type\":\"bool\"}],\"name\":\"WhitelistOnlyPermissionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"}],\"name\":\"WhitelistFactProviderAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"factProvider\",\"type\":\"address\"}],\"name\":\"WhitelistFactProviderRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// PassportLogicContractBin is the compiled bytecode used for deploying new contracts.
const PassportLogicContractBin = `0x608060408190527f6f72672e6d6f6e657468612e70726f78792e6f776e6572000000000000000000905261003b3364010000000061009a810204565b604080517f6f72672e6d6f6e657468612e70726f78792e70656e64696e674f776e657200008152905190819003601e0190207fcfd0c6ea5352192d7d4c5d4e7a73c5da12c871730cb60ff57879cbe7b403bb521461009557fe5b6100be565b7f3ca57e4b51fc2e18497b219410298879868edada7e6fe5132c8feceb0a080d2255565b6130e480620000ce6000396000f3006080604052600436106102455763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166306427a88811461024a57806308c50498146102645780630a2565251461027c5780630e14a376146102a3578063174a6277146102bb57806320888158146102fa57806322b96b631461032f578063257781e7146103d65780632b42a89a146103ee5780632c62ff2d146104085780632db27bd2146104205780632e28d084146104cb5780633e49bed0146104ef5780634e71e0c81461050a5780635b2a372d1461051f578063616b59f61461054357806361a2d0761461055b57806363019d1d146105705780636556f767146105885780636bfc8bb5146105ac5780636d4e7802146105d05780636e899550146105f15780636f618f9a14610615578063715018a6146107bc57806371658552146107d15780637ac4ed64146107f55780637dd291e41461083c57806386ca9a7c146108515780638ae44a081461085f5780638c160095146108805780638da5cb5b1461089857806395ee8bae146108c95780639d74b37d146108ed578063a2b6cbe11461092c578063ab338e361461027c578063abfdcced14610944578063ac0aeb1a14610961578063ca446dd914610982578063caa95f1b146109a6578063cea332cc146109bb578063e2a4853a146109e2578063e2b202bf146109fd578063e30c397814610a15578063e318de7314610a2a578063e75a836a14610a4e578063f2fde38b14610a75578063f6bb3cc414610a96578063fc2d058414610aae575b600080fd5b34801561025657600080fd5b50610262600435610ac9565b005b34801561027057600080fd5b50610262600435610d01565b34801561028857600080fd5b50610291610f21565b60408051918252519081900360200190f35b3480156102af57600080fd5b50610262600435610f28565b3480156102c757600080fd5b506102df600160a060020a0360043516602435610f34565b60408051921515835260208301919091528051918290030190f35b34801561030657600080fd5b5061031b600160a060020a0360043516610f4c565b604080519115158252519081900360200190f35b34801561033b57600080fd5b50610353600160a060020a0360043516602435610fa2565b604051808315151515815260200180602001828103825283818151815260200191508051906020019080838360005b8381101561039a578181015183820152602001610382565b50505050905090810190601f1680156103c75780820380516001836020036101000a031916815260200191505b50935050505060405180910390f35b3480156103e257600080fd5b50610262600435610fb0565b3480156103fa57600080fd5b506102626004351515610fb9565b34801561041457600080fd5b50610262600435611012565b34801561042c57600080fd5b50610444600160a060020a036004351660243561101b565b604080518415158152908101829052606060208083018281528551928401929092528451608084019186019080838360005b8381101561048e578181015183820152602001610476565b50505050905090810190601f1680156104bb5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390f35b3480156104d757600080fd5b50610262600480359060248035908101910135611038565b3480156104fb57600080fd5b50610262600435602435611077565b34801561051657600080fd5b50610262611085565b34801561052b57600080fd5b50610262600480359060248035908101910135611168565b34801561054f57600080fd5b506102626004356111ed565b34801561056757600080fd5b5061031b6111f6565b34801561057c57600080fd5b50610262600435611200565b34801561059457600080fd5b50610353600160a060020a0360043516602435611209565b3480156105b857600080fd5b50610262600480359060248035908101910135611217565b3480156105dc57600080fd5b50610262600160a060020a0360043516611251565b3480156105fd57600080fd5b506102626004803590602480359081019101356112b6565b34801561062157600080fd5b5061062d6004356112f0565b604051808e600160a060020a0316600160a060020a031681526020018d81526020018c600160a060020a0316600160a060020a031681526020018b81526020018a600160a060020a0316600160a060020a03168152602001896000191660001916815260200180602001886000191660001916815260200180602001876000191660001916815260200186600019166000191681526020018560028111156106d157fe5b60ff16815260200184815260200183810383528a818151815260200191508051906020019080838360005b838110156107145781810151838201526020016106fc565b50505050905090810190601f1680156107415780820380516001836020036101000a031916815260200191505b5083810382528851815288516020918201918a019080838360005b8381101561077457818101518382015260200161075c565b50505050905090810190601f1680156107a15780820380516001836020036101000a031916815260200191505b509f5050505050505050505050505050505060405180910390f35b3480156107c857600080fd5b50610262611490565b3480156107dd57600080fd5b506102df600160a060020a0360043516602435611550565b34801561080157600080fd5b50610819600160a060020a036004351660243561155d565b604080519215158352600160a060020a0390911660208301528051918290030190f35b34801561084857600080fd5b5061029161156a565b610262600435602435611570565b34801561086b57600080fd5b5061031b600160a060020a0360043516611807565b34801561088c57600080fd5b50610262600435611825565b3480156108a457600080fd5b506108ad61182e565b60408051600160a060020a039092168252519081900360200190f35b3480156108d557600080fd5b506102df600160a060020a036004351660243561183d565b3480156108f957600080fd5b50610911600160a060020a036004351660243561184a565b60408051921515835290151560208301528051918290030190f35b34801561093857600080fd5b50610262600435611857565b34801561095057600080fd5b5061026260043560243515156118be565b34801561096d57600080fd5b50610262600160a060020a03600435166118c8565b34801561098e57600080fd5b50610262600435600160a060020a0360243516611930565b3480156109b257600080fd5b5061029161193a565b61026260048035600160a060020a0316906024803591604435918201910135606435611940565b3480156109ee57600080fd5b50610262600435602435611cd2565b348015610a0957600080fd5b50610262600435611cdc565b348015610a2157600080fd5b506108ad611ce5565b348015610a3657600080fd5b50610353600160a060020a0360043516602435611cef565b348015610a5a57600080fd5b50610262600480359060248035908101910135604435611cfd565b348015610a8157600080fd5b50610262600160a060020a0360043516611d3f565b348015610aa257600080fd5b50610262600435611dc1565b348015610aba57600080fd5b50610262600435602435611dca565b600c5460009081908310610b15576040805160e560020a62461bcd0281526020600482015260166024820152600080516020613099833981519152604482015290519081900360640190fd5b600c805484908110610b2357fe5b60009182526020909120600d90910201600b81015490925060ff166002811115610b4957fe5b600214610bae576040805160e560020a62461bcd02815260206004820152602260248201527f65786368616e6765206d75737420626520696e20616363657074656420737461604482015260f060020a61746502606482015290519081900360840190fd5b81600c0154610bbb612205565b1180610bd057508154600160a060020a031633145b1515610c73576040805160e560020a62461bcd028152602060048201526044602482018190527f65786368616e6765206d75737420626520656974686572206578706972656420908201527f6f722062652066696e697368656420627920746865206461746120726571756560648201527f7374657200000000000000000000000000000000000000000000000000000000608482015290519081900360a40190fd5b600b8201805460ff1916905560038201546001830154610c9291612228565b6002830154604051919250600160a060020a03169082156108fc029083906000818181858888f193505050501515610cc957600080fd5b610cd1612235565b60405183907f5d1a7ae2ffda31cae15ed5129d32260ef2a270a21325f536f7954ed297e52c8e90600090a2505050565b600c546000908210610d4b576040805160e560020a62461bcd0281526020600482015260166024820152600080516020613099833981519152604482015290519081900360640190fd5b600c805483908110610d5957fe5b60009182526020909120600d90910201600b81015490915060ff166002811115610d7f57fe5b600114610de4576040805160e560020a62461bcd02815260206004820152602260248201527f65786368616e6765206d75737420626520696e2070726f706f73656420737461604482015260f060020a61746502606482015290519081900360840190fd5b8054600160a060020a03163314610e45576040805160e560020a62461bcd02815260206004820152601b60248201527f6f6e6c7920646174612072657175657374657220616c6c6f7765640000000000604482015290519081900360640190fd5b80600c0154610e52612205565b11610ea7576040805160e560020a62461bcd02815260206004820152601860248201527f65786368616e6765206d75737420626520657870697265640000000000000000604482015290519081900360640190fd5b600b8101805460ff1916905580546001820154604051600160a060020a03909216916108fc82150291906000818181858888f193505050501515610eea57600080fd5b610ef2612235565b60405182907f5d1a7ae2ffda31cae15ed5129d32260ef2a270a21325f536f7954ed297e52c8e90600090a25050565b6201518081565b610f3181612251565b50565b600080610f4184846122c4565b915091509250929050565b60075460009060ff161580610f795750600160a060020a03821660009081526008602052604090205460ff165b80610f9c5750610f876122f8565b600160a060020a031682600160a060020a0316145b92915050565b60006060610f41848461231d565b610f31816123e7565b610fc16122f8565b600160a060020a03163314610fd557600080fd5b6007805460ff19168215159081179091556040517f6e1eb3fa845047cf9d5fd1deb1b7770b4e26163dd4d88cefb14fe7964a70059590600090a250565b610f318161245d565b60006060600061102b85856124bf565b9250925092509250925092565b6110728383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375061258f945050505050565b505050565b6110818282612629565b5050565b61108d6126ad565b600160a060020a031633146110a157600080fd5b6110a96126d2565b156110fe576040805160e560020a62461bcd02815260206004820152601d60248201527f636f6e74726163742073686f756c64206e6f7420626520706175736564000000604482015290519081900360640190fd5b6111066126ad565b600160a060020a03166111176122f8565b600160a060020a03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a361115c6111576126ad565b6126f7565b611166600061271b565b565b61117133610f4c565b151561117c57600080fd5b6040805180820182526001808252436020808401918252336000818152600683528681208a82529092528582209451855460ff191690151517855591519390920192909255915185927fcbde9cd310365ff3de3ad9cb44ed688d8880c7b1d15df733a73880fb84d032de91a3505050565b610f318161273f565b60075460ff165b90565b610f31816127b5565b60006060610f418484612837565b6110728383838080601f016020809104026020016040519081016040528093929190818152602001838380828437506128c3945050505050565b6112596122f8565b600160a060020a0316331461126d57600080fd5b600160a060020a038116600081815260086020526040808220805460ff19169055517f5bf47f016603dfff957e6086bd9a350212686e8f1d9208b3db47c5a3107c78789190a250565b6110728383838080601f0160208091040260200160405190810160405280939291908181526020018383808284375061295d945050505050565b600c8054829081106112fe57fe5b6000918252602091829020600d90910201805460018083015460028085015460038601546004870154600588015460068901805460408051601f6000199b841615610100029b909b01909216979097049889018c90048c0281018c01909652878652600160a060020a039889169b509599938816989297919091169590949193928301828280156113d05780601f106113a5576101008083540402835291602001916113d0565b820191906000526020600020905b8154815290600101906020018083116113b357829003601f168201915b50505050600783015460088401805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815295969395939450908301828280156114675780601f1061143c57610100808354040283529160200191611467565b820191906000526020600020905b81548152906001019060200180831161144a57829003601f168201915b5050506009840154600a850154600b860154600c909601549495919490935060ff90911691508d565b6114986122f8565b600160a060020a031633146114ac57600080fd5b6114b46126d2565b15611509576040805160e560020a62461bcd02815260206004820152601d60248201527f636f6e74726163742073686f756c64206e6f7420626520706175736564000000604482015290519081900360640190fd5b6115116122f8565b600160a060020a03167ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482060405160405180910390a261116660006126f7565b600080610f4184846129f7565b600080610f418484612a2a565b600c5490565b600c5460009083106115ba576040805160e560020a62461bcd0281526020600482015260166024820152600080516020613099833981519152604482015290519081900360640190fd5b600c8054849081106115c857fe5b60009182526020909120600d909102016002810154909150600160a060020a0316331461163f576040805160e560020a62461bcd02815260206004820152601b60248201527f6f6e6c792070617373706f7274206f776e657220616c6c6f7765640000000000604482015290519081900360640190fd5b600b81015460ff16600281111561165257fe5b6001146116b7576040805160e560020a62461bcd02815260206004820152602260248201527f65786368616e6765206d75737420626520696e2070726f706f73656420737461604482015260f060020a61746502606482015290519081900360840190fd5b6001810154341015611739576040805160e560020a62461bcd02815260206004820152602c60248201527f6e65656420746f207374616b65206174206c656173742064617461207265717560448201527f657374657220616d6f756e740000000000000000000000000000000000000000606482015290519081900360840190fd5b80600c0154611746612205565b1061179b576040805160e560020a62461bcd02815260206004820152601660248201527f65786368616e6765207374617465206578706972656400000000000000000000604482015290519081900360640190fd5b346003820155600a8101829055600b8101805460ff19166002179055620151806117c3612205565b01600c82015580546040513391600160a060020a03169085907f843dda373d0d243dce80a6cd203b9cbba8576d036c7eb937f9de36ebe6e8b02390600090a4505050565b600160a060020a031660009081526008602052604090205460ff1690565b610f3181612a5d565b60006118386122f8565b905090565b600080610f418484612ac4565b600080610f418484612af8565b61186033610f4c565b151561186b57600080fd5b336000818152600660209081526040808320858452909152808220805460ff19168155600101829055518392917f9b9532c8ba5879554dee7c3e9374bd26dbfb2f79cf7f247bcf90648fc81fc16491a350565b6110818282612b2d565b6118d06122f8565b600160a060020a031633146118e457600080fd5b600160a060020a038116600081815260086020526040808220805460ff19166001179055517fff8ac5f0e9cdc8f7ffbbc29ab1301ee649cf01cf7a6a9265a2d90587612c41759190a250565b6110818282612bc0565b600b5481565b600060606000806000611951612f59565b600061195d8c8c6124bf565b9650965096508615156119ba576040805160e560020a62461bcd02815260206004820152601760248201527f707269766174652064617461206d757374206578697374000000000000000000604482015290519081900360640190fd5b6119c26122f8565b93506101a06040519081016040528033600160a060020a0316815260200134815260200185600160a060020a03168152602001600081526020018d600160a060020a031681526020018c600019168152602001878152602001866000191681526020018b8b8080601f016020809104026020016040519081016040528093929190818152602001838380828437505050928452505050602081018a9052604081018590526060016001815260200162015180611a7c612205565b019052600c8054600181018083556000929092528251600d9091027fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c781018054600160a060020a0393841673ffffffffffffffffffffffffffffffffffffffff199182161782556020808701517fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c885015560408701517fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c98501805491871691841691909117905560608701517fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8ca85015560808701517fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8cb850180549190961692169190911790935560a08501517fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8cc83015560c08501518051959750939487949193611c0a937fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8cd01920190612fc4565b5060e082015160078201556101008201518051611c31916008840191602090910190612fc4565b506101208201516009820155610140820151600a820155610160820151600b8201805460ff19166001836002811115611c6657fe5b021790555061018082015181600c0155505050611c81612c6e565b50600c5460405160001990910190600160a060020a03851690339083907fabe53237e9ea366da7fa5507ac62db22bd446d6b66bcff4a6d6c1b11e9af198390600090a4505050505050505050505050565b6110818282612c8b565b610f3181612d0e565b60006118386126ad565b60006060610f418484612d75565b611d398484848080601f01602080910402602001604051908101604052809392919081815260200183838082843750889450612e019350505050565b50505050565b611d476122f8565b600160a060020a03163314611d5b57600080fd5b611d636126d2565b15611db8576040805160e560020a62461bcd02815260206004820152601d60248201527f636f6e74726163742073686f756c64206e6f7420626520706175736564000000604482015290519081900360640190fd5b610f318161271b565b610f3181612ebf565b6000806000806000600c8054905087101515611e1e576040805160e560020a62461bcd0281526020600482015260166024820152600080516020613099833981519152604482015290519081900360640190fd5b600c805488908110611e2c57fe5b60009182526020909120600d90910201600b81015490955060ff166002811115611e5257fe5b600214611eb7576040805160e560020a62461bcd02815260206004820152602260248201527f65786368616e6765206d75737420626520696e20616363657074656420737461604482015260f060020a61746502606482015290519081900360840190fd5b8454600160a060020a03163314611f18576040805160e560020a62461bcd02815260206004820152601b60248201527f6f6e6c7920646174612072657175657374657220616c6c6f7765640000000000604482015290519081900360640190fd5b84600c0154611f25612205565b10611f7a576040805160e560020a62461bcd02815260206004820152601c60248201527f65786368616e6765206d757374206e6f74206265206578706972656400000000604482015290519081900360640190fd5b60098501546040805160208082018a905282518083038201815291830192839052815191929182918401908083835b60208310611fc85780518252601f199092019160209182019101611fa9565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902060001916141515612050576040805160e560020a62461bcd02815260206004820152601c60248201527f65786368616e6765206b65792068617368206d757374206d6174636800000000604482015290519081900360640190fd5b600a85015460078601546040805192891860208085018290528251808603820181529483019283905284519198509293928291908401908083835b602083106120aa5780518252601f19909201916020918201910161208b565b5181516020939093036101000a60001901801990911692169190911790526040519201829003909120600b8a01805460ff1916905560038a015460018b01549590911497506120fe94935091506122289050565b9150821561214d576002850154604051600160a060020a039091169083156108fc029084906000818181858888f19350505050151561213c57600080fd5b508354600160a060020a0316612190565b8454604051600160a060020a039091169083156108fc029084906000818181858888f19350505050151561218057600080fd5b506002840154600160a060020a03165b612198612235565b60405187907f5d1a7ae2ffda31cae15ed5129d32260ef2a270a21325f536f7954ed297e52c8e90600090a2604051600160a060020a0382169084159089907f540941e0fc2370abde0bfa6ddbb49188469597e518416fa24327f39469c9b2ec90600090a450505050505050565b600042670214e8348c4f000081111561222057633b9aca0090045b8091505b5090565b81810182811015610f9c57fe5b600b805460001901908190551515611166576111666000612f35565b61225a33610f4c565b151561226557600080fd5b33600081815260208181526040808320858452909152808220805474ffffffffffffffffffffffffffffffffffffffffff19169055518392917fed9474c4702ee9da4d0d2085840fafed5912b8e13daf1d6ea341ebe98803aec291a350565b600160a060020a0391909116600090815260066020908152604080832093835292905220805460019091015460ff90911691565b7f3ca57e4b51fc2e18497b219410298879868edada7e6fe5132c8feceb0a080d225490565b600160a060020a038216600090815260096020908152604080832084845282528083208054600180830180548551601f600294831615610100026000190190921693909304908101879004870283018701909552848252606095939460ff90931693909283918301828280156123d45780601f106123a9576101008083540402835291602001916123d4565b820191906000526020600020905b8154815290600101906020018083116123b757829003601f168201915b5050505050905092509250509250929050565b6123f033610f4c565b15156123fb57600080fd5b3360009081526009602090815260408083208484529091528120805460ff191681559061242b600183018261303e565b5050604051819033907f140278d2322b9671bf293aea878e7717c46d5b7cd955e3e426ee67e01b90165490600090a350565b61246633610f4c565b151561247157600080fd5b336000818152600360209081526040808320858452909152808220805461ffff19169055518392917f191bd7fc1f22ce6b74b7d7e42126f0ed225b109728607c99971de9e78b0db6eb91a350565b600160a060020a0382166000908152600a6020908152604080832084845282528083208054600280830154600180850180548751601f93821615610100026000190190911694909404918201889004880284018801909652808352606096889660ff909516949391849183018282801561257a5780601f1061254f5761010080835404028352916020019161257a565b820191906000526020600020905b81548152906001019060200180831161255d57829003601f168201915b50505050509150935093509350509250925092565b61259833610f4c565b15156125a357600080fd5b60408051808201825260018082526020808301858152336000908152600583528581208882528352949094208351815460ff1916901515178155935180519394936125f5938501929190910190612fc4565b505060405183915033907fee56af66250a5cbba377132a356dc403d520776e30969594927024c44af8440b90600090a35050565b61263233610f4c565b151561263d57600080fd5b60408051808201825260018082526020808301858152336000818152600284528681208982529093528583209451855460ff19169015151785559051939092019290925591518492917fdb4ad6a3ed2bdacbae02da45a5bb54192cdb7d72648674d13e08d2fc4c45ac6691a35050565b7fcfd0c6ea5352192d7d4c5d4e7a73c5da12c871730cb60ff57879cbe7b403bb525490565b7f9e7945c55c116aa3404b99fe56db7af9613d3b899554a437c2616a4749a94d8a5490565b7f3ca57e4b51fc2e18497b219410298879868edada7e6fe5132c8feceb0a080d2255565b7fcfd0c6ea5352192d7d4c5d4e7a73c5da12c871730cb60ff57879cbe7b403bb5255565b61274833610f4c565b151561275357600080fd5b3360009081526005602090815260408083208484529091528120805460ff1916815590612783600183018261303e565b5050604051819033907f0eaf95ab41777ff88e28181b1c43418524616bcef6d37c3b216015b5548cb10890600090a350565b6127be33610f4c565b15156127c957600080fd5b336000908152600a602090815260408083208484529091528120805460ff191681559060018201816127fb828261303e565b5060006001919091018190556040518493503392507f9cad6db22e9f7e2a3441e18ef08567fa48da09796f593ded4222f0a315f986019190a350565b600160a060020a038216600090815260056020908152604080832084845282528083208054600180830180548551601f600294831615610100026000190190921693909304908101879004870283018701909552848252606095939460ff90931693909283918301828280156123d45780601f106123a9576101008083540402835291602001916123d4565b6128cc33610f4c565b15156128d757600080fd5b60408051808201825260018082526020808301858152336000908152600983528581208882528352949094208351815460ff191690151517815593518051939493612929938501929190910190612fc4565b505060405183915033907fdb23beee028623a85d5af1d247423ca471d20e499b131cd5e5c76277eaa2ad5b90600090a35050565b61296633610f4c565b151561297157600080fd5b60408051808201825260018082526020808301858152336000908152600483528581208882528352949094208351815460ff1916901515178155935180519394936129c3938501929190910190612fc4565b505060405183915033907f43e6b7e3323b4598401023341c086c07c3ff5577f594b5aab9c065f2c3c9d59090600090a35050565b600160a060020a03919091166000908152600160208181526040808420948452939052919020805491015460ff90911691565b600160a060020a03918216600090815260208181526040808320938352929052205460ff81169261010090910490911690565b612a6633610f4c565b1515612a7157600080fd5b336000818152600260209081526040808320858452909152808220805460ff19168155600101829055518392917f3c3ff48e02e407eb1e78310d11b5e3f9e735263a9cafc2bcf4aa981b8ecb32a591a350565b600160a060020a0391909116600090815260026020908152604080832093835292905220805460019091015460ff90911691565b600160a060020a03919091166000908152600360209081526040808320938352929052205460ff808216926101009092041690565b612b3633610f4c565b1515612b4157600080fd5b6040805180820182526001815282151560208083019182523360008181526003835285812088825290925284822093518454935115156101000261ff001991151560ff1990951694909417169290921790925591518492917f68cc3496efaac4c1f2c0cd52da916138f6c5fc541992f05d97423a89b6914ae591a35050565b612bc933610f4c565b1515612bd457600080fd5b60408051808201825260018152600160a060020a03838116602080840191825233600081815280835286812089825290925285822094518554935160ff199094169015151774ffffffffffffffffffffffffffffffffffffffff001916610100939094169290920292909217909255915184927f8e7e6ab6c4613205e833e1faf5415d78dd10130a8828f729c08036e2a7a6277091a35050565b600b80546001908101918290551415611166576111666001612f35565b612c9433610f4c565b1515612c9f57600080fd5b604080518082018252600180825260208083018581523360008181528484528681208982529093528583209451855460ff19169015151785559051939092019290925591518492917fff76cb7634629f8d05011ab2a58380dfc0743157a70ba4173f866e113eca75c091a35050565b612d1733610f4c565b1515612d2257600080fd5b336000818152600160208181526040808420868552909152808320805460ff19168155909101829055518392917fd5f853f7aaba549b5a46be1de24cac4c20e716b4c603d24b2b0b7b5d97ca1c4d91a350565b600160a060020a038216600090815260046020908152604080832084845282528083208054600180830180548551601f600294831615610100026000190190921693909304908101879004870283018701909552848252606095939460ff90931693909283918301828280156123d45780601f106123a9576101008083540402835291602001916123d4565b612e0a33610f4c565b1515612e1557600080fd5b6040805180820182526001808252825180840184528581526020808201869052808401918252336000908152600a82528581208982528252949094208351815460ff1916901515178155905180518051949592949193850192612e7d92849290910190612fc4565b50602091909101516001909101555050604051839033907f0ed4013fbc8174781b18a7aa1cce7d589bc1fc3509941835787881ed2ab8b48e90600090a3505050565b612ec833610f4c565b1515612ed357600080fd5b3360009081526004602090815260408083208484529091528120805460ff1916815590612f03600183018261303e565b5050604051819033907f491a0e0281af9fc88ff024cffc24db22eddd4f826cb30d84936592967dc9237c90600090a350565b7f9e7945c55c116aa3404b99fe56db7af9613d3b899554a437c2616a4749a94d8a55565b604080516101a08101825260008082526020820181905291810182905260608082018390526080820183905260a0820183905260c0820181905260e0820183905261010082015261012081018290526101408101829052906101608201908152602001600081525090565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061300557805160ff1916838001178555613032565b82800160010185558215613032579182015b82811115613032578251825591602001919060010190613017565b5061222492915061307e565b50805460018160011615610100020316600290046000825580601f106130645750610f31565b601f016020900490600052602060002090810190610f3191905b6111fd91905b8082111561222457600081556001016130845600696e76616c69642065786368616e676520696e64657800000000000000000000a165627a7a7230582041a953d855a89eeb04b17625df1e5d4e4ba5cf90f9ccebdde1870b02399e475a0029`

// DeployPassportLogicContract deploys a new Ethereum contract, binding an instance of PassportLogicContract to it.
func DeployPassportLogicContract(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *PassportLogicContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PassportLogicContractABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(PassportLogicContractBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &PassportLogicContract{PassportLogicContractCaller: PassportLogicContractCaller{contract: contract}, PassportLogicContractTransactor: PassportLogicContractTransactor{contract: contract}, PassportLogicContractFilterer: PassportLogicContractFilterer{contract: contract}}, nil
}

// PassportLogicContract is an auto generated Go binding around an Ethereum contract.
type PassportLogicContract struct {
	PassportLogicContractCaller     // Read-only binding to the contract
	PassportLogicContractTransactor // Write-only binding to the contract
	PassportLogicContractFilterer   // Log filterer for contract events
}

// PassportLogicContractCaller is an auto generated read-only Go binding around an Ethereum contract.
type PassportLogicContractCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PassportLogicContractTransactor is an auto generated write-only Go binding around an Ethereum contract.
type PassportLogicContractTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PassportLogicContractFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type PassportLogicContractFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// PassportLogicContractSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type PassportLogicContractSession struct {
	Contract     *PassportLogicContract // Generic contract binding to set the session for
	CallOpts     bind.CallOpts          // Call options to use throughout this session
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// PassportLogicContractCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type PassportLogicContractCallerSession struct {
	Contract *PassportLogicContractCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                // Call options to use throughout this session
}

// PassportLogicContractTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type PassportLogicContractTransactorSession struct {
	Contract     *PassportLogicContractTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                // Transaction auth options to use throughout this session
}

// PassportLogicContractRaw is an auto generated low-level Go binding around an Ethereum contract.
type PassportLogicContractRaw struct {
	Contract *PassportLogicContract // Generic contract binding to access the raw methods on
}

// PassportLogicContractCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type PassportLogicContractCallerRaw struct {
	Contract *PassportLogicContractCaller // Generic read-only contract binding to access the raw methods on
}

// PassportLogicContractTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type PassportLogicContractTransactorRaw struct {
	Contract *PassportLogicContractTransactor // Generic write-only contract binding to access the raw methods on
}

// NewPassportLogicContract creates a new instance of PassportLogicContract, bound to a specific deployed contract.
func NewPassportLogicContract(address common.Address, backend bind.ContractBackend) (*PassportLogicContract, error) {
	contract, err := bindPassportLogicContract(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContract{PassportLogicContractCaller: PassportLogicContractCaller{contract: contract}, PassportLogicContractTransactor: PassportLogicContractTransactor{contract: contract}, PassportLogicContractFilterer: PassportLogicContractFilterer{contract: contract}}, nil
}

// NewPassportLogicContractCaller creates a new read-only instance of PassportLogicContract, bound to a specific deployed contract.
func NewPassportLogicContractCaller(address common.Address, caller bind.ContractCaller) (*PassportLogicContractCaller, error) {
	contract, err := bindPassportLogicContract(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractCaller{contract: contract}, nil
}

// NewPassportLogicContractTransactor creates a new write-only instance of PassportLogicContract, bound to a specific deployed contract.
func NewPassportLogicContractTransactor(address common.Address, transactor bind.ContractTransactor) (*PassportLogicContractTransactor, error) {
	contract, err := bindPassportLogicContract(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractTransactor{contract: contract}, nil
}

// NewPassportLogicContractFilterer creates a new log filterer instance of PassportLogicContract, bound to a specific deployed contract.
func NewPassportLogicContractFilterer(address common.Address, filterer bind.ContractFilterer) (*PassportLogicContractFilterer, error) {
	contract, err := bindPassportLogicContract(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractFilterer{contract: contract}, nil
}

// bindPassportLogicContract binds a generic wrapper to an already deployed contract.
func bindPassportLogicContract(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(PassportLogicContractABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PassportLogicContract *PassportLogicContractRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _PassportLogicContract.Contract.PassportLogicContractCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PassportLogicContract *PassportLogicContractRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.PassportLogicContractTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PassportLogicContract *PassportLogicContractRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.PassportLogicContractTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_PassportLogicContract *PassportLogicContractCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _PassportLogicContract.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_PassportLogicContract *PassportLogicContractTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_PassportLogicContract *PassportLogicContractTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.contract.Transact(opts, method, params...)
}

// GetAddress is a free data retrieval call binding the contract method 0x7ac4ed64.
//
// Solidity: function getAddress(address _factProvider, bytes32 _key) constant returns(bool success, address value)
func (_PassportLogicContract *PassportLogicContractCaller) GetAddress(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   common.Address
}, error) {
	ret := new(struct {
		Success bool
		Value   common.Address
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getAddress", _factProvider, _key)
	return *ret, err
}

// GetAddress is a free data retrieval call binding the contract method 0x7ac4ed64.
//
// Solidity: function getAddress(address _factProvider, bytes32 _key) constant returns(bool success, address value)
func (_PassportLogicContract *PassportLogicContractSession) GetAddress(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   common.Address
}, error) {
	return _PassportLogicContract.Contract.GetAddress(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetAddress is a free data retrieval call binding the contract method 0x7ac4ed64.
//
// Solidity: function getAddress(address _factProvider, bytes32 _key) constant returns(bool success, address value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetAddress(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   common.Address
}, error) {
	return _PassportLogicContract.Contract.GetAddress(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetBool is a free data retrieval call binding the contract method 0x9d74b37d.
//
// Solidity: function getBool(address _factProvider, bytes32 _key) constant returns(bool success, bool value)
func (_PassportLogicContract *PassportLogicContractCaller) GetBool(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   bool
}, error) {
	ret := new(struct {
		Success bool
		Value   bool
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getBool", _factProvider, _key)
	return *ret, err
}

// GetBool is a free data retrieval call binding the contract method 0x9d74b37d.
//
// Solidity: function getBool(address _factProvider, bytes32 _key) constant returns(bool success, bool value)
func (_PassportLogicContract *PassportLogicContractSession) GetBool(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   bool
}, error) {
	return _PassportLogicContract.Contract.GetBool(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetBool is a free data retrieval call binding the contract method 0x9d74b37d.
//
// Solidity: function getBool(address _factProvider, bytes32 _key) constant returns(bool success, bool value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetBool(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   bool
}, error) {
	return _PassportLogicContract.Contract.GetBool(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetBytes is a free data retrieval call binding the contract method 0x6556f767.
//
// Solidity: function getBytes(address _factProvider, bytes32 _key) constant returns(bool success, bytes value)
func (_PassportLogicContract *PassportLogicContractCaller) GetBytes(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   []byte
}, error) {
	ret := new(struct {
		Success bool
		Value   []byte
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getBytes", _factProvider, _key)
	return *ret, err
}

// GetBytes is a free data retrieval call binding the contract method 0x6556f767.
//
// Solidity: function getBytes(address _factProvider, bytes32 _key) constant returns(bool success, bytes value)
func (_PassportLogicContract *PassportLogicContractSession) GetBytes(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   []byte
}, error) {
	return _PassportLogicContract.Contract.GetBytes(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetBytes is a free data retrieval call binding the contract method 0x6556f767.
//
// Solidity: function getBytes(address _factProvider, bytes32 _key) constant returns(bool success, bytes value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetBytes(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   []byte
}, error) {
	return _PassportLogicContract.Contract.GetBytes(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetIPFSHash is a free data retrieval call binding the contract method 0x22b96b63.
//
// Solidity: function getIPFSHash(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractCaller) GetIPFSHash(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	ret := new(struct {
		Success bool
		Value   string
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getIPFSHash", _factProvider, _key)
	return *ret, err
}

// GetIPFSHash is a free data retrieval call binding the contract method 0x22b96b63.
//
// Solidity: function getIPFSHash(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractSession) GetIPFSHash(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	return _PassportLogicContract.Contract.GetIPFSHash(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetIPFSHash is a free data retrieval call binding the contract method 0x22b96b63.
//
// Solidity: function getIPFSHash(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetIPFSHash(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	return _PassportLogicContract.Contract.GetIPFSHash(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetInt is a free data retrieval call binding the contract method 0x95ee8bae.
//
// Solidity: function getInt(address _factProvider, bytes32 _key) constant returns(bool success, int256 value)
func (_PassportLogicContract *PassportLogicContractCaller) GetInt(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	ret := new(struct {
		Success bool
		Value   *big.Int
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getInt", _factProvider, _key)
	return *ret, err
}

// GetInt is a free data retrieval call binding the contract method 0x95ee8bae.
//
// Solidity: function getInt(address _factProvider, bytes32 _key) constant returns(bool success, int256 value)
func (_PassportLogicContract *PassportLogicContractSession) GetInt(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetInt(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetInt is a free data retrieval call binding the contract method 0x95ee8bae.
//
// Solidity: function getInt(address _factProvider, bytes32 _key) constant returns(bool success, int256 value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetInt(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetInt(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetPrivateDataExchangesCount is a free data retrieval call binding the contract method 0x7dd291e4.
//
// Solidity: function getPrivateDataExchangesCount() constant returns(uint256 count)
func (_PassportLogicContract *PassportLogicContractCaller) GetPrivateDataExchangesCount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "getPrivateDataExchangesCount")
	return *ret0, err
}

// GetPrivateDataExchangesCount is a free data retrieval call binding the contract method 0x7dd291e4.
//
// Solidity: function getPrivateDataExchangesCount() constant returns(uint256 count)
func (_PassportLogicContract *PassportLogicContractSession) GetPrivateDataExchangesCount() (*big.Int, error) {
	return _PassportLogicContract.Contract.GetPrivateDataExchangesCount(&_PassportLogicContract.CallOpts)
}

// GetPrivateDataExchangesCount is a free data retrieval call binding the contract method 0x7dd291e4.
//
// Solidity: function getPrivateDataExchangesCount() constant returns(uint256 count)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetPrivateDataExchangesCount() (*big.Int, error) {
	return _PassportLogicContract.Contract.GetPrivateDataExchangesCount(&_PassportLogicContract.CallOpts)
}

// GetPrivateDataHashes is a free data retrieval call binding the contract method 0x2db27bd2.
//
// Solidity: function getPrivateDataHashes(address _factProvider, bytes32 _key) constant returns(bool success, string dataIPFSHash, bytes32 dataKeyHash)
func (_PassportLogicContract *PassportLogicContractCaller) GetPrivateDataHashes(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success      bool
	DataIPFSHash string
	DataKeyHash  [32]byte
}, error) {
	ret := new(struct {
		Success      bool
		DataIPFSHash string
		DataKeyHash  [32]byte
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getPrivateDataHashes", _factProvider, _key)
	return *ret, err
}

// GetPrivateDataHashes is a free data retrieval call binding the contract method 0x2db27bd2.
//
// Solidity: function getPrivateDataHashes(address _factProvider, bytes32 _key) constant returns(bool success, string dataIPFSHash, bytes32 dataKeyHash)
func (_PassportLogicContract *PassportLogicContractSession) GetPrivateDataHashes(_factProvider common.Address, _key [32]byte) (struct {
	Success      bool
	DataIPFSHash string
	DataKeyHash  [32]byte
}, error) {
	return _PassportLogicContract.Contract.GetPrivateDataHashes(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetPrivateDataHashes is a free data retrieval call binding the contract method 0x2db27bd2.
//
// Solidity: function getPrivateDataHashes(address _factProvider, bytes32 _key) constant returns(bool success, string dataIPFSHash, bytes32 dataKeyHash)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetPrivateDataHashes(_factProvider common.Address, _key [32]byte) (struct {
	Success      bool
	DataIPFSHash string
	DataKeyHash  [32]byte
}, error) {
	return _PassportLogicContract.Contract.GetPrivateDataHashes(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetString is a free data retrieval call binding the contract method 0xe318de73.
//
// Solidity: function getString(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractCaller) GetString(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	ret := new(struct {
		Success bool
		Value   string
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getString", _factProvider, _key)
	return *ret, err
}

// GetString is a free data retrieval call binding the contract method 0xe318de73.
//
// Solidity: function getString(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractSession) GetString(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	return _PassportLogicContract.Contract.GetString(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetString is a free data retrieval call binding the contract method 0xe318de73.
//
// Solidity: function getString(address _factProvider, bytes32 _key) constant returns(bool success, string value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetString(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   string
}, error) {
	return _PassportLogicContract.Contract.GetString(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetTxDataBlockNumber is a free data retrieval call binding the contract method 0x174a6277.
//
// Solidity: function getTxDataBlockNumber(address _factProvider, bytes32 _key) constant returns(bool success, uint256 blockNumber)
func (_PassportLogicContract *PassportLogicContractCaller) GetTxDataBlockNumber(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success     bool
	BlockNumber *big.Int
}, error) {
	ret := new(struct {
		Success     bool
		BlockNumber *big.Int
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getTxDataBlockNumber", _factProvider, _key)
	return *ret, err
}

// GetTxDataBlockNumber is a free data retrieval call binding the contract method 0x174a6277.
//
// Solidity: function getTxDataBlockNumber(address _factProvider, bytes32 _key) constant returns(bool success, uint256 blockNumber)
func (_PassportLogicContract *PassportLogicContractSession) GetTxDataBlockNumber(_factProvider common.Address, _key [32]byte) (struct {
	Success     bool
	BlockNumber *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetTxDataBlockNumber(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetTxDataBlockNumber is a free data retrieval call binding the contract method 0x174a6277.
//
// Solidity: function getTxDataBlockNumber(address _factProvider, bytes32 _key) constant returns(bool success, uint256 blockNumber)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetTxDataBlockNumber(_factProvider common.Address, _key [32]byte) (struct {
	Success     bool
	BlockNumber *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetTxDataBlockNumber(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetUint is a free data retrieval call binding the contract method 0x71658552.
//
// Solidity: function getUint(address _factProvider, bytes32 _key) constant returns(bool success, uint256 value)
func (_PassportLogicContract *PassportLogicContractCaller) GetUint(opts *bind.CallOpts, _factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	ret := new(struct {
		Success bool
		Value   *big.Int
	})
	out := ret
	err := _PassportLogicContract.contract.Call(opts, out, "getUint", _factProvider, _key)
	return *ret, err
}

// GetUint is a free data retrieval call binding the contract method 0x71658552.
//
// Solidity: function getUint(address _factProvider, bytes32 _key) constant returns(bool success, uint256 value)
func (_PassportLogicContract *PassportLogicContractSession) GetUint(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetUint(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// GetUint is a free data retrieval call binding the contract method 0x71658552.
//
// Solidity: function getUint(address _factProvider, bytes32 _key) constant returns(bool success, uint256 value)
func (_PassportLogicContract *PassportLogicContractCallerSession) GetUint(_factProvider common.Address, _key [32]byte) (struct {
	Success bool
	Value   *big.Int
}, error) {
	return _PassportLogicContract.Contract.GetUint(&_PassportLogicContract.CallOpts, _factProvider, _key)
}

// IsAllowedFactProvider is a free data retrieval call binding the contract method 0x20888158.
//
// Solidity: function isAllowedFactProvider(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCaller) IsAllowedFactProvider(opts *bind.CallOpts, _address common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "isAllowedFactProvider", _address)
	return *ret0, err
}

// IsAllowedFactProvider is a free data retrieval call binding the contract method 0x20888158.
//
// Solidity: function isAllowedFactProvider(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractSession) IsAllowedFactProvider(_address common.Address) (bool, error) {
	return _PassportLogicContract.Contract.IsAllowedFactProvider(&_PassportLogicContract.CallOpts, _address)
}

// IsAllowedFactProvider is a free data retrieval call binding the contract method 0x20888158.
//
// Solidity: function isAllowedFactProvider(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCallerSession) IsAllowedFactProvider(_address common.Address) (bool, error) {
	return _PassportLogicContract.Contract.IsAllowedFactProvider(&_PassportLogicContract.CallOpts, _address)
}

// IsFactProviderInWhitelist is a free data retrieval call binding the contract method 0x8ae44a08.
//
// Solidity: function isFactProviderInWhitelist(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCaller) IsFactProviderInWhitelist(opts *bind.CallOpts, _address common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "isFactProviderInWhitelist", _address)
	return *ret0, err
}

// IsFactProviderInWhitelist is a free data retrieval call binding the contract method 0x8ae44a08.
//
// Solidity: function isFactProviderInWhitelist(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractSession) IsFactProviderInWhitelist(_address common.Address) (bool, error) {
	return _PassportLogicContract.Contract.IsFactProviderInWhitelist(&_PassportLogicContract.CallOpts, _address)
}

// IsFactProviderInWhitelist is a free data retrieval call binding the contract method 0x8ae44a08.
//
// Solidity: function isFactProviderInWhitelist(address _address) constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCallerSession) IsFactProviderInWhitelist(_address common.Address) (bool, error) {
	return _PassportLogicContract.Contract.IsFactProviderInWhitelist(&_PassportLogicContract.CallOpts, _address)
}

// IsWhitelistOnlyPermissionSet is a free data retrieval call binding the contract method 0x61a2d076.
//
// Solidity: function isWhitelistOnlyPermissionSet() constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCaller) IsWhitelistOnlyPermissionSet(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "isWhitelistOnlyPermissionSet")
	return *ret0, err
}

// IsWhitelistOnlyPermissionSet is a free data retrieval call binding the contract method 0x61a2d076.
//
// Solidity: function isWhitelistOnlyPermissionSet() constant returns(bool)
func (_PassportLogicContract *PassportLogicContractSession) IsWhitelistOnlyPermissionSet() (bool, error) {
	return _PassportLogicContract.Contract.IsWhitelistOnlyPermissionSet(&_PassportLogicContract.CallOpts)
}

// IsWhitelistOnlyPermissionSet is a free data retrieval call binding the contract method 0x61a2d076.
//
// Solidity: function isWhitelistOnlyPermissionSet() constant returns(bool)
func (_PassportLogicContract *PassportLogicContractCallerSession) IsWhitelistOnlyPermissionSet() (bool, error) {
	return _PassportLogicContract.Contract.IsWhitelistOnlyPermissionSet(&_PassportLogicContract.CallOpts)
}

// OpenPrivateDataExchangesCount is a free data retrieval call binding the contract method 0xcaa95f1b.
//
// Solidity: function openPrivateDataExchangesCount() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCaller) OpenPrivateDataExchangesCount(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "openPrivateDataExchangesCount")
	return *ret0, err
}

// OpenPrivateDataExchangesCount is a free data retrieval call binding the contract method 0xcaa95f1b.
//
// Solidity: function openPrivateDataExchangesCount() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractSession) OpenPrivateDataExchangesCount() (*big.Int, error) {
	return _PassportLogicContract.Contract.OpenPrivateDataExchangesCount(&_PassportLogicContract.CallOpts)
}

// OpenPrivateDataExchangesCount is a free data retrieval call binding the contract method 0xcaa95f1b.
//
// Solidity: function openPrivateDataExchangesCount() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCallerSession) OpenPrivateDataExchangesCount() (*big.Int, error) {
	return _PassportLogicContract.Contract.OpenPrivateDataExchangesCount(&_PassportLogicContract.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractSession) Owner() (common.Address, error) {
	return _PassportLogicContract.Contract.Owner(&_PassportLogicContract.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractCallerSession) Owner() (common.Address, error) {
	return _PassportLogicContract.Contract.Owner(&_PassportLogicContract.CallOpts)
}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractCaller) PendingOwner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "pendingOwner")
	return *ret0, err
}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractSession) PendingOwner() (common.Address, error) {
	return _PassportLogicContract.Contract.PendingOwner(&_PassportLogicContract.CallOpts)
}

// PendingOwner is a free data retrieval call binding the contract method 0xe30c3978.
//
// Solidity: function pendingOwner() constant returns(address)
func (_PassportLogicContract *PassportLogicContractCallerSession) PendingOwner() (common.Address, error) {
	return _PassportLogicContract.Contract.PendingOwner(&_PassportLogicContract.CallOpts)
}

// PrivateDataExchangeAcceptTimeout is a free data retrieval call binding the contract method 0x0a256525.
//
// Solidity: function privateDataExchangeAcceptTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCaller) PrivateDataExchangeAcceptTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "privateDataExchangeAcceptTimeout")
	return *ret0, err
}

// PrivateDataExchangeAcceptTimeout is a free data retrieval call binding the contract method 0x0a256525.
//
// Solidity: function privateDataExchangeAcceptTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractSession) PrivateDataExchangeAcceptTimeout() (*big.Int, error) {
	return _PassportLogicContract.Contract.PrivateDataExchangeAcceptTimeout(&_PassportLogicContract.CallOpts)
}

// PrivateDataExchangeAcceptTimeout is a free data retrieval call binding the contract method 0x0a256525.
//
// Solidity: function privateDataExchangeAcceptTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCallerSession) PrivateDataExchangeAcceptTimeout() (*big.Int, error) {
	return _PassportLogicContract.Contract.PrivateDataExchangeAcceptTimeout(&_PassportLogicContract.CallOpts)
}

// PrivateDataExchangeProposeTimeout is a free data retrieval call binding the contract method 0xab338e36.
//
// Solidity: function privateDataExchangeProposeTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCaller) PrivateDataExchangeProposeTimeout(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _PassportLogicContract.contract.Call(opts, out, "privateDataExchangeProposeTimeout")
	return *ret0, err
}

// PrivateDataExchangeProposeTimeout is a free data retrieval call binding the contract method 0xab338e36.
//
// Solidity: function privateDataExchangeProposeTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractSession) PrivateDataExchangeProposeTimeout() (*big.Int, error) {
	return _PassportLogicContract.Contract.PrivateDataExchangeProposeTimeout(&_PassportLogicContract.CallOpts)
}

// PrivateDataExchangeProposeTimeout is a free data retrieval call binding the contract method 0xab338e36.
//
// Solidity: function privateDataExchangeProposeTimeout() constant returns(uint256)
func (_PassportLogicContract *PassportLogicContractCallerSession) PrivateDataExchangeProposeTimeout() (*big.Int, error) {
	return _PassportLogicContract.Contract.PrivateDataExchangeProposeTimeout(&_PassportLogicContract.CallOpts)
}

// PrivateDataExchanges is a free data retrieval call binding the contract method 0x6f618f9a.
//
// Solidity: function privateDataExchanges(uint256 ) constant returns(address dataRequester, uint256 dataRequesterValue, address passportOwner, uint256 passportOwnerValue, address factProvider, bytes32 key, string dataIPFSHash, bytes32 dataKeyHash, bytes encryptedExchangeKey, bytes32 exchangeKeyHash, bytes32 encryptedDataKey, uint8 state, uint256 stateExpired)
func (_PassportLogicContract *PassportLogicContractCaller) PrivateDataExchanges(opts *bind.CallOpts, arg0 *big.Int) (struct {
	DataRequester        common.Address
	DataRequesterValue   *big.Int
	PassportOwner        common.Address
	PassportOwnerValue   *big.Int
	FactProvider         common.Address
	Key                  [32]byte
	DataIPFSHash         string
	DataKeyHash          [32]byte
	EncryptedExchangeKey []byte
	ExchangeKeyHash      [32]byte
	EncryptedDataKey     [32]byte
	State                uint8
	StateExpired         *big.Int
}, error) {
	ret := new(struct {
		DataRequester        common.Address
		DataRequesterValue   *big.Int
		PassportOwner        common.Address
		PassportOwnerValue   *big.Int
		FactProvider         common.Address
		Key                  [32]byte
		DataIPFSHash         string
		DataKeyHash          [32]byte
		EncryptedExchangeKey []byte
		ExchangeKeyHash      [32]byte
		EncryptedDataKey     [32]byte
		State                uint8
		StateExpired         *big.Int
	})

	var retCount *big.Int
	err := _PassportLogicContract.contract.Call(opts, &retCount, "getPrivateDataExchangesCount")
	if err != nil {
		return *ret, err
	}
	if arg0.Int64() >= retCount.Int64() {
		return *ret, fmt.Errorf("the number of private data exchanges is %d, so private data exchange index should be <%d", retCount, retCount)
	}

	out := ret
	err = _PassportLogicContract.contract.Call(opts, out, "privateDataExchanges", arg0)
	return *ret, err
}

// PrivateDataExchanges is a free data retrieval call binding the contract method 0x6f618f9a.
//
// Solidity: function privateDataExchanges(uint256 ) constant returns(address dataRequester, uint256 dataRequesterValue, address passportOwner, uint256 passportOwnerValue, address factProvider, bytes32 key, string dataIPFSHash, bytes32 dataKeyHash, bytes encryptedExchangeKey, bytes32 exchangeKeyHash, bytes32 encryptedDataKey, uint8 state, uint256 stateExpired)
func (_PassportLogicContract *PassportLogicContractSession) PrivateDataExchanges(arg0 *big.Int) (struct {
	DataRequester        common.Address
	DataRequesterValue   *big.Int
	PassportOwner        common.Address
	PassportOwnerValue   *big.Int
	FactProvider         common.Address
	Key                  [32]byte
	DataIPFSHash         string
	DataKeyHash          [32]byte
	EncryptedExchangeKey []byte
	ExchangeKeyHash      [32]byte
	EncryptedDataKey     [32]byte
	State                uint8
	StateExpired         *big.Int
}, error) {
	return _PassportLogicContract.Contract.PrivateDataExchanges(&_PassportLogicContract.CallOpts, arg0)
}

// PrivateDataExchanges is a free data retrieval call binding the contract method 0x6f618f9a.
//
// Solidity: function privateDataExchanges(uint256 ) constant returns(address dataRequester, uint256 dataRequesterValue, address passportOwner, uint256 passportOwnerValue, address factProvider, bytes32 key, string dataIPFSHash, bytes32 dataKeyHash, bytes encryptedExchangeKey, bytes32 exchangeKeyHash, bytes32 encryptedDataKey, uint8 state, uint256 stateExpired)
func (_PassportLogicContract *PassportLogicContractCallerSession) PrivateDataExchanges(arg0 *big.Int) (struct {
	DataRequester        common.Address
	DataRequesterValue   *big.Int
	PassportOwner        common.Address
	PassportOwnerValue   *big.Int
	FactProvider         common.Address
	Key                  [32]byte
	DataIPFSHash         string
	DataKeyHash          [32]byte
	EncryptedExchangeKey []byte
	ExchangeKeyHash      [32]byte
	EncryptedDataKey     [32]byte
	State                uint8
	StateExpired         *big.Int
}, error) {
	return _PassportLogicContract.Contract.PrivateDataExchanges(&_PassportLogicContract.CallOpts, arg0)
}

// AcceptPrivateDataExchange is a paid mutator transaction binding the contract method 0x86ca9a7c.
//
// Solidity: function acceptPrivateDataExchange(uint256 _exchangeIdx, bytes32 _encryptedDataKey) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) AcceptPrivateDataExchange(opts *bind.TransactOpts, _exchangeIdx *big.Int, _encryptedDataKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "acceptPrivateDataExchange", _exchangeIdx, _encryptedDataKey)
}

// AcceptPrivateDataExchange is a paid mutator transaction binding the contract method 0x86ca9a7c.
//
// Solidity: function acceptPrivateDataExchange(uint256 _exchangeIdx, bytes32 _encryptedDataKey) returns()
func (_PassportLogicContract *PassportLogicContractSession) AcceptPrivateDataExchange(_exchangeIdx *big.Int, _encryptedDataKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.AcceptPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx, _encryptedDataKey)
}

// AcceptPrivateDataExchange is a paid mutator transaction binding the contract method 0x86ca9a7c.
//
// Solidity: function acceptPrivateDataExchange(uint256 _exchangeIdx, bytes32 _encryptedDataKey) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) AcceptPrivateDataExchange(_exchangeIdx *big.Int, _encryptedDataKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.AcceptPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx, _encryptedDataKey)
}

// AddFactProviderToWhitelist is a paid mutator transaction binding the contract method 0xac0aeb1a.
//
// Solidity: function addFactProviderToWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) AddFactProviderToWhitelist(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "addFactProviderToWhitelist", _address)
}

// AddFactProviderToWhitelist is a paid mutator transaction binding the contract method 0xac0aeb1a.
//
// Solidity: function addFactProviderToWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractSession) AddFactProviderToWhitelist(_address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.AddFactProviderToWhitelist(&_PassportLogicContract.TransactOpts, _address)
}

// AddFactProviderToWhitelist is a paid mutator transaction binding the contract method 0xac0aeb1a.
//
// Solidity: function addFactProviderToWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) AddFactProviderToWhitelist(_address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.AddFactProviderToWhitelist(&_PassportLogicContract.TransactOpts, _address)
}

// ClaimOwnership is a paid mutator transaction binding the contract method 0x4e71e0c8.
//
// Solidity: function claimOwnership() returns()
func (_PassportLogicContract *PassportLogicContractTransactor) ClaimOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "claimOwnership")
}

// ClaimOwnership is a paid mutator transaction binding the contract method 0x4e71e0c8.
//
// Solidity: function claimOwnership() returns()
func (_PassportLogicContract *PassportLogicContractSession) ClaimOwnership() (*types.Transaction, error) {
	return _PassportLogicContract.Contract.ClaimOwnership(&_PassportLogicContract.TransactOpts)
}

// ClaimOwnership is a paid mutator transaction binding the contract method 0x4e71e0c8.
//
// Solidity: function claimOwnership() returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) ClaimOwnership() (*types.Transaction, error) {
	return _PassportLogicContract.Contract.ClaimOwnership(&_PassportLogicContract.TransactOpts)
}

// DeleteAddress is a paid mutator transaction binding the contract method 0x0e14a376.
//
// Solidity: function deleteAddress(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteAddress(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteAddress", _key)
}

// DeleteAddress is a paid mutator transaction binding the contract method 0x0e14a376.
//
// Solidity: function deleteAddress(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteAddress(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteAddress(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteAddress is a paid mutator transaction binding the contract method 0x0e14a376.
//
// Solidity: function deleteAddress(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteAddress(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteAddress(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteBool is a paid mutator transaction binding the contract method 0x2c62ff2d.
//
// Solidity: function deleteBool(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteBool(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteBool", _key)
}

// DeleteBool is a paid mutator transaction binding the contract method 0x2c62ff2d.
//
// Solidity: function deleteBool(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteBool(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteBool(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteBool is a paid mutator transaction binding the contract method 0x2c62ff2d.
//
// Solidity: function deleteBool(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteBool(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteBool(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteBytes is a paid mutator transaction binding the contract method 0x616b59f6.
//
// Solidity: function deleteBytes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteBytes(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteBytes", _key)
}

// DeleteBytes is a paid mutator transaction binding the contract method 0x616b59f6.
//
// Solidity: function deleteBytes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteBytes(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteBytes(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteBytes is a paid mutator transaction binding the contract method 0x616b59f6.
//
// Solidity: function deleteBytes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteBytes(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteBytes(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteIPFSHash is a paid mutator transaction binding the contract method 0x257781e7.
//
// Solidity: function deleteIPFSHash(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteIPFSHash(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteIPFSHash", _key)
}

// DeleteIPFSHash is a paid mutator transaction binding the contract method 0x257781e7.
//
// Solidity: function deleteIPFSHash(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteIPFSHash(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteIPFSHash(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteIPFSHash is a paid mutator transaction binding the contract method 0x257781e7.
//
// Solidity: function deleteIPFSHash(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteIPFSHash(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteIPFSHash(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteInt is a paid mutator transaction binding the contract method 0x8c160095.
//
// Solidity: function deleteInt(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteInt(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteInt", _key)
}

// DeleteInt is a paid mutator transaction binding the contract method 0x8c160095.
//
// Solidity: function deleteInt(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteInt(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteInt(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteInt is a paid mutator transaction binding the contract method 0x8c160095.
//
// Solidity: function deleteInt(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteInt(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteInt(&_PassportLogicContract.TransactOpts, _key)
}

// DeletePrivateDataHashes is a paid mutator transaction binding the contract method 0x63019d1d.
//
// Solidity: function deletePrivateDataHashes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeletePrivateDataHashes(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deletePrivateDataHashes", _key)
}

// DeletePrivateDataHashes is a paid mutator transaction binding the contract method 0x63019d1d.
//
// Solidity: function deletePrivateDataHashes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeletePrivateDataHashes(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeletePrivateDataHashes(&_PassportLogicContract.TransactOpts, _key)
}

// DeletePrivateDataHashes is a paid mutator transaction binding the contract method 0x63019d1d.
//
// Solidity: function deletePrivateDataHashes(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeletePrivateDataHashes(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeletePrivateDataHashes(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteString is a paid mutator transaction binding the contract method 0xf6bb3cc4.
//
// Solidity: function deleteString(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteString(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteString", _key)
}

// DeleteString is a paid mutator transaction binding the contract method 0xf6bb3cc4.
//
// Solidity: function deleteString(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteString(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteString(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteString is a paid mutator transaction binding the contract method 0xf6bb3cc4.
//
// Solidity: function deleteString(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteString(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteString(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteTxDataBlockNumber is a paid mutator transaction binding the contract method 0xa2b6cbe1.
//
// Solidity: function deleteTxDataBlockNumber(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteTxDataBlockNumber(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteTxDataBlockNumber", _key)
}

// DeleteTxDataBlockNumber is a paid mutator transaction binding the contract method 0xa2b6cbe1.
//
// Solidity: function deleteTxDataBlockNumber(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteTxDataBlockNumber(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteTxDataBlockNumber(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteTxDataBlockNumber is a paid mutator transaction binding the contract method 0xa2b6cbe1.
//
// Solidity: function deleteTxDataBlockNumber(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteTxDataBlockNumber(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteTxDataBlockNumber(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteUint is a paid mutator transaction binding the contract method 0xe2b202bf.
//
// Solidity: function deleteUint(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DeleteUint(opts *bind.TransactOpts, _key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "deleteUint", _key)
}

// DeleteUint is a paid mutator transaction binding the contract method 0xe2b202bf.
//
// Solidity: function deleteUint(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractSession) DeleteUint(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteUint(&_PassportLogicContract.TransactOpts, _key)
}

// DeleteUint is a paid mutator transaction binding the contract method 0xe2b202bf.
//
// Solidity: function deleteUint(bytes32 _key) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DeleteUint(_key [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DeleteUint(&_PassportLogicContract.TransactOpts, _key)
}

// DisputePrivateDataExchange is a paid mutator transaction binding the contract method 0xfc2d0584.
//
// Solidity: function disputePrivateDataExchange(uint256 _exchangeIdx, bytes32 _exchangeKey) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) DisputePrivateDataExchange(opts *bind.TransactOpts, _exchangeIdx *big.Int, _exchangeKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "disputePrivateDataExchange", _exchangeIdx, _exchangeKey)
}

// DisputePrivateDataExchange is a paid mutator transaction binding the contract method 0xfc2d0584.
//
// Solidity: function disputePrivateDataExchange(uint256 _exchangeIdx, bytes32 _exchangeKey) returns()
func (_PassportLogicContract *PassportLogicContractSession) DisputePrivateDataExchange(_exchangeIdx *big.Int, _exchangeKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DisputePrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx, _exchangeKey)
}

// DisputePrivateDataExchange is a paid mutator transaction binding the contract method 0xfc2d0584.
//
// Solidity: function disputePrivateDataExchange(uint256 _exchangeIdx, bytes32 _exchangeKey) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) DisputePrivateDataExchange(_exchangeIdx *big.Int, _exchangeKey [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.DisputePrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx, _exchangeKey)
}

// FinishPrivateDataExchange is a paid mutator transaction binding the contract method 0x06427a88.
//
// Solidity: function finishPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) FinishPrivateDataExchange(opts *bind.TransactOpts, _exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "finishPrivateDataExchange", _exchangeIdx)
}

// FinishPrivateDataExchange is a paid mutator transaction binding the contract method 0x06427a88.
//
// Solidity: function finishPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractSession) FinishPrivateDataExchange(_exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.FinishPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx)
}

// FinishPrivateDataExchange is a paid mutator transaction binding the contract method 0x06427a88.
//
// Solidity: function finishPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) FinishPrivateDataExchange(_exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.FinishPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx)
}

// ProposePrivateDataExchange is a paid mutator transaction binding the contract method 0xcea332cc.
//
// Solidity: function proposePrivateDataExchange(address _factProvider, bytes32 _key, bytes _encryptedExchangeKey, bytes32 _exchangeKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) ProposePrivateDataExchange(opts *bind.TransactOpts, _factProvider common.Address, _key [32]byte, _encryptedExchangeKey []byte, _exchangeKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "proposePrivateDataExchange", _factProvider, _key, _encryptedExchangeKey, _exchangeKeyHash)
}

// ProposePrivateDataExchange is a paid mutator transaction binding the contract method 0xcea332cc.
//
// Solidity: function proposePrivateDataExchange(address _factProvider, bytes32 _key, bytes _encryptedExchangeKey, bytes32 _exchangeKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractSession) ProposePrivateDataExchange(_factProvider common.Address, _key [32]byte, _encryptedExchangeKey []byte, _exchangeKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.ProposePrivateDataExchange(&_PassportLogicContract.TransactOpts, _factProvider, _key, _encryptedExchangeKey, _exchangeKeyHash)
}

// ProposePrivateDataExchange is a paid mutator transaction binding the contract method 0xcea332cc.
//
// Solidity: function proposePrivateDataExchange(address _factProvider, bytes32 _key, bytes _encryptedExchangeKey, bytes32 _exchangeKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) ProposePrivateDataExchange(_factProvider common.Address, _key [32]byte, _encryptedExchangeKey []byte, _exchangeKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.ProposePrivateDataExchange(&_PassportLogicContract.TransactOpts, _factProvider, _key, _encryptedExchangeKey, _exchangeKeyHash)
}

// RemoveFactProviderFromWhitelist is a paid mutator transaction binding the contract method 0x6d4e7802.
//
// Solidity: function removeFactProviderFromWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) RemoveFactProviderFromWhitelist(opts *bind.TransactOpts, _address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "removeFactProviderFromWhitelist", _address)
}

// RemoveFactProviderFromWhitelist is a paid mutator transaction binding the contract method 0x6d4e7802.
//
// Solidity: function removeFactProviderFromWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractSession) RemoveFactProviderFromWhitelist(_address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.RemoveFactProviderFromWhitelist(&_PassportLogicContract.TransactOpts, _address)
}

// RemoveFactProviderFromWhitelist is a paid mutator transaction binding the contract method 0x6d4e7802.
//
// Solidity: function removeFactProviderFromWhitelist(address _address) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) RemoveFactProviderFromWhitelist(_address common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.RemoveFactProviderFromWhitelist(&_PassportLogicContract.TransactOpts, _address)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PassportLogicContract *PassportLogicContractTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PassportLogicContract *PassportLogicContractSession) RenounceOwnership() (*types.Transaction, error) {
	return _PassportLogicContract.Contract.RenounceOwnership(&_PassportLogicContract.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _PassportLogicContract.Contract.RenounceOwnership(&_PassportLogicContract.TransactOpts)
}

// SetAddress is a paid mutator transaction binding the contract method 0xca446dd9.
//
// Solidity: function setAddress(bytes32 _key, address _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetAddress(opts *bind.TransactOpts, _key [32]byte, _value common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setAddress", _key, _value)
}

// SetAddress is a paid mutator transaction binding the contract method 0xca446dd9.
//
// Solidity: function setAddress(bytes32 _key, address _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetAddress(_key [32]byte, _value common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetAddress(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetAddress is a paid mutator transaction binding the contract method 0xca446dd9.
//
// Solidity: function setAddress(bytes32 _key, address _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetAddress(_key [32]byte, _value common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetAddress(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetBool is a paid mutator transaction binding the contract method 0xabfdcced.
//
// Solidity: function setBool(bytes32 _key, bool _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetBool(opts *bind.TransactOpts, _key [32]byte, _value bool) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setBool", _key, _value)
}

// SetBool is a paid mutator transaction binding the contract method 0xabfdcced.
//
// Solidity: function setBool(bytes32 _key, bool _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetBool(_key [32]byte, _value bool) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetBool(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetBool is a paid mutator transaction binding the contract method 0xabfdcced.
//
// Solidity: function setBool(bytes32 _key, bool _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetBool(_key [32]byte, _value bool) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetBool(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetBytes is a paid mutator transaction binding the contract method 0x2e28d084.
//
// Solidity: function setBytes(bytes32 _key, bytes _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetBytes(opts *bind.TransactOpts, _key [32]byte, _value []byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setBytes", _key, _value)
}

// SetBytes is a paid mutator transaction binding the contract method 0x2e28d084.
//
// Solidity: function setBytes(bytes32 _key, bytes _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetBytes(_key [32]byte, _value []byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetBytes(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetBytes is a paid mutator transaction binding the contract method 0x2e28d084.
//
// Solidity: function setBytes(bytes32 _key, bytes _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetBytes(_key [32]byte, _value []byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetBytes(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetIPFSHash is a paid mutator transaction binding the contract method 0x6bfc8bb5.
//
// Solidity: function setIPFSHash(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetIPFSHash(opts *bind.TransactOpts, _key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setIPFSHash", _key, _value)
}

// SetIPFSHash is a paid mutator transaction binding the contract method 0x6bfc8bb5.
//
// Solidity: function setIPFSHash(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetIPFSHash(_key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetIPFSHash(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetIPFSHash is a paid mutator transaction binding the contract method 0x6bfc8bb5.
//
// Solidity: function setIPFSHash(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetIPFSHash(_key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetIPFSHash(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetInt is a paid mutator transaction binding the contract method 0x3e49bed0.
//
// Solidity: function setInt(bytes32 _key, int256 _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetInt(opts *bind.TransactOpts, _key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setInt", _key, _value)
}

// SetInt is a paid mutator transaction binding the contract method 0x3e49bed0.
//
// Solidity: function setInt(bytes32 _key, int256 _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetInt(_key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetInt(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetInt is a paid mutator transaction binding the contract method 0x3e49bed0.
//
// Solidity: function setInt(bytes32 _key, int256 _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetInt(_key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetInt(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetPrivateDataHashes is a paid mutator transaction binding the contract method 0xe75a836a.
//
// Solidity: function setPrivateDataHashes(bytes32 _key, string _dataIPFSHash, bytes32 _dataKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetPrivateDataHashes(opts *bind.TransactOpts, _key [32]byte, _dataIPFSHash string, _dataKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setPrivateDataHashes", _key, _dataIPFSHash, _dataKeyHash)
}

// SetPrivateDataHashes is a paid mutator transaction binding the contract method 0xe75a836a.
//
// Solidity: function setPrivateDataHashes(bytes32 _key, string _dataIPFSHash, bytes32 _dataKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetPrivateDataHashes(_key [32]byte, _dataIPFSHash string, _dataKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetPrivateDataHashes(&_PassportLogicContract.TransactOpts, _key, _dataIPFSHash, _dataKeyHash)
}

// SetPrivateDataHashes is a paid mutator transaction binding the contract method 0xe75a836a.
//
// Solidity: function setPrivateDataHashes(bytes32 _key, string _dataIPFSHash, bytes32 _dataKeyHash) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetPrivateDataHashes(_key [32]byte, _dataIPFSHash string, _dataKeyHash [32]byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetPrivateDataHashes(&_PassportLogicContract.TransactOpts, _key, _dataIPFSHash, _dataKeyHash)
}

// SetString is a paid mutator transaction binding the contract method 0x6e899550.
//
// Solidity: function setString(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetString(opts *bind.TransactOpts, _key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setString", _key, _value)
}

// SetString is a paid mutator transaction binding the contract method 0x6e899550.
//
// Solidity: function setString(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetString(_key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetString(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetString is a paid mutator transaction binding the contract method 0x6e899550.
//
// Solidity: function setString(bytes32 _key, string _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetString(_key [32]byte, _value string) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetString(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetTxDataBlockNumber is a paid mutator transaction binding the contract method 0x5b2a372d.
//
// Solidity: function setTxDataBlockNumber(bytes32 _key, bytes _data) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetTxDataBlockNumber(opts *bind.TransactOpts, _key [32]byte, _data []byte) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setTxDataBlockNumber", _key, _data)
}

// SetTxDataBlockNumber is a paid mutator transaction binding the contract method 0x5b2a372d.
//
// Solidity: function setTxDataBlockNumber(bytes32 _key, bytes _data) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetTxDataBlockNumber(_key [32]byte, _data []byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetTxDataBlockNumber(&_PassportLogicContract.TransactOpts, _key, _data)
}

// SetTxDataBlockNumber is a paid mutator transaction binding the contract method 0x5b2a372d.
//
// Solidity: function setTxDataBlockNumber(bytes32 _key, bytes _data) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetTxDataBlockNumber(_key [32]byte, _data []byte) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetTxDataBlockNumber(&_PassportLogicContract.TransactOpts, _key, _data)
}

// SetUint is a paid mutator transaction binding the contract method 0xe2a4853a.
//
// Solidity: function setUint(bytes32 _key, uint256 _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetUint(opts *bind.TransactOpts, _key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setUint", _key, _value)
}

// SetUint is a paid mutator transaction binding the contract method 0xe2a4853a.
//
// Solidity: function setUint(bytes32 _key, uint256 _value) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetUint(_key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetUint(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetUint is a paid mutator transaction binding the contract method 0xe2a4853a.
//
// Solidity: function setUint(bytes32 _key, uint256 _value) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetUint(_key [32]byte, _value *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetUint(&_PassportLogicContract.TransactOpts, _key, _value)
}

// SetWhitelistOnlyPermission is a paid mutator transaction binding the contract method 0x2b42a89a.
//
// Solidity: function setWhitelistOnlyPermission(bool _onlyWhitelist) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) SetWhitelistOnlyPermission(opts *bind.TransactOpts, _onlyWhitelist bool) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "setWhitelistOnlyPermission", _onlyWhitelist)
}

// SetWhitelistOnlyPermission is a paid mutator transaction binding the contract method 0x2b42a89a.
//
// Solidity: function setWhitelistOnlyPermission(bool _onlyWhitelist) returns()
func (_PassportLogicContract *PassportLogicContractSession) SetWhitelistOnlyPermission(_onlyWhitelist bool) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetWhitelistOnlyPermission(&_PassportLogicContract.TransactOpts, _onlyWhitelist)
}

// SetWhitelistOnlyPermission is a paid mutator transaction binding the contract method 0x2b42a89a.
//
// Solidity: function setWhitelistOnlyPermission(bool _onlyWhitelist) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) SetWhitelistOnlyPermission(_onlyWhitelist bool) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.SetWhitelistOnlyPermission(&_PassportLogicContract.TransactOpts, _onlyWhitelist)
}

// TimeoutPrivateDataExchange is a paid mutator transaction binding the contract method 0x08c50498.
//
// Solidity: function timeoutPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) TimeoutPrivateDataExchange(opts *bind.TransactOpts, _exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "timeoutPrivateDataExchange", _exchangeIdx)
}

// TimeoutPrivateDataExchange is a paid mutator transaction binding the contract method 0x08c50498.
//
// Solidity: function timeoutPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractSession) TimeoutPrivateDataExchange(_exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.TimeoutPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx)
}

// TimeoutPrivateDataExchange is a paid mutator transaction binding the contract method 0x08c50498.
//
// Solidity: function timeoutPrivateDataExchange(uint256 _exchangeIdx) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) TimeoutPrivateDataExchange(_exchangeIdx *big.Int) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.TimeoutPrivateDataExchange(&_PassportLogicContract.TransactOpts, _exchangeIdx)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PassportLogicContract *PassportLogicContractTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PassportLogicContract *PassportLogicContractSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.TransferOwnership(&_PassportLogicContract.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_PassportLogicContract *PassportLogicContractTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _PassportLogicContract.Contract.TransferOwnership(&_PassportLogicContract.TransactOpts, newOwner)
}

// PassportLogicContractAddressDeletedIterator is returned from FilterAddressDeleted and is used to iterate over the raw logs and unpacked data for AddressDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractAddressDeletedIterator struct {
	Event *PassportLogicContractAddressDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractAddressDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractAddressDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractAddressDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractAddressDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractAddressDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractAddressDeleted represents a AddressDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractAddressDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAddressDeleted is a free log retrieval operation binding the contract event 0xed9474c4702ee9da4d0d2085840fafed5912b8e13daf1d6ea341ebe98803aec2.
//
// Solidity: event AddressDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterAddressDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractAddressDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "AddressDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractAddressDeletedIterator{contract: _PassportLogicContract.contract, event: "AddressDeleted", logs: logs, sub: sub}, nil
}

// WatchAddressDeleted is a free log subscription operation binding the contract event 0xed9474c4702ee9da4d0d2085840fafed5912b8e13daf1d6ea341ebe98803aec2.
//
// Solidity: event AddressDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchAddressDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractAddressDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "AddressDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractAddressDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "AddressDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractAddressUpdatedIterator is returned from FilterAddressUpdated and is used to iterate over the raw logs and unpacked data for AddressUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractAddressUpdatedIterator struct {
	Event *PassportLogicContractAddressUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractAddressUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractAddressUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractAddressUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractAddressUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractAddressUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractAddressUpdated represents a AddressUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractAddressUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterAddressUpdated is a free log retrieval operation binding the contract event 0x8e7e6ab6c4613205e833e1faf5415d78dd10130a8828f729c08036e2a7a62770.
//
// Solidity: event AddressUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterAddressUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractAddressUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "AddressUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractAddressUpdatedIterator{contract: _PassportLogicContract.contract, event: "AddressUpdated", logs: logs, sub: sub}, nil
}

// WatchAddressUpdated is a free log subscription operation binding the contract event 0x8e7e6ab6c4613205e833e1faf5415d78dd10130a8828f729c08036e2a7a62770.
//
// Solidity: event AddressUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchAddressUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractAddressUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "AddressUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractAddressUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "AddressUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractBoolDeletedIterator is returned from FilterBoolDeleted and is used to iterate over the raw logs and unpacked data for BoolDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractBoolDeletedIterator struct {
	Event *PassportLogicContractBoolDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractBoolDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractBoolDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractBoolDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractBoolDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractBoolDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractBoolDeleted represents a BoolDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractBoolDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBoolDeleted is a free log retrieval operation binding the contract event 0x191bd7fc1f22ce6b74b7d7e42126f0ed225b109728607c99971de9e78b0db6eb.
//
// Solidity: event BoolDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterBoolDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractBoolDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "BoolDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractBoolDeletedIterator{contract: _PassportLogicContract.contract, event: "BoolDeleted", logs: logs, sub: sub}, nil
}

// WatchBoolDeleted is a free log subscription operation binding the contract event 0x191bd7fc1f22ce6b74b7d7e42126f0ed225b109728607c99971de9e78b0db6eb.
//
// Solidity: event BoolDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchBoolDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractBoolDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "BoolDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractBoolDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "BoolDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractBoolUpdatedIterator is returned from FilterBoolUpdated and is used to iterate over the raw logs and unpacked data for BoolUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractBoolUpdatedIterator struct {
	Event *PassportLogicContractBoolUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractBoolUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractBoolUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractBoolUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractBoolUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractBoolUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractBoolUpdated represents a BoolUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractBoolUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBoolUpdated is a free log retrieval operation binding the contract event 0x68cc3496efaac4c1f2c0cd52da916138f6c5fc541992f05d97423a89b6914ae5.
//
// Solidity: event BoolUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterBoolUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractBoolUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "BoolUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractBoolUpdatedIterator{contract: _PassportLogicContract.contract, event: "BoolUpdated", logs: logs, sub: sub}, nil
}

// WatchBoolUpdated is a free log subscription operation binding the contract event 0x68cc3496efaac4c1f2c0cd52da916138f6c5fc541992f05d97423a89b6914ae5.
//
// Solidity: event BoolUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchBoolUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractBoolUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "BoolUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractBoolUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "BoolUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractBytesDeletedIterator is returned from FilterBytesDeleted and is used to iterate over the raw logs and unpacked data for BytesDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractBytesDeletedIterator struct {
	Event *PassportLogicContractBytesDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractBytesDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractBytesDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractBytesDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractBytesDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractBytesDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractBytesDeleted represents a BytesDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractBytesDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBytesDeleted is a free log retrieval operation binding the contract event 0x0eaf95ab41777ff88e28181b1c43418524616bcef6d37c3b216015b5548cb108.
//
// Solidity: event BytesDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterBytesDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractBytesDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "BytesDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractBytesDeletedIterator{contract: _PassportLogicContract.contract, event: "BytesDeleted", logs: logs, sub: sub}, nil
}

// WatchBytesDeleted is a free log subscription operation binding the contract event 0x0eaf95ab41777ff88e28181b1c43418524616bcef6d37c3b216015b5548cb108.
//
// Solidity: event BytesDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchBytesDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractBytesDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "BytesDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractBytesDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "BytesDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractBytesUpdatedIterator is returned from FilterBytesUpdated and is used to iterate over the raw logs and unpacked data for BytesUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractBytesUpdatedIterator struct {
	Event *PassportLogicContractBytesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractBytesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractBytesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractBytesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractBytesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractBytesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractBytesUpdated represents a BytesUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractBytesUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBytesUpdated is a free log retrieval operation binding the contract event 0xee56af66250a5cbba377132a356dc403d520776e30969594927024c44af8440b.
//
// Solidity: event BytesUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterBytesUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractBytesUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "BytesUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractBytesUpdatedIterator{contract: _PassportLogicContract.contract, event: "BytesUpdated", logs: logs, sub: sub}, nil
}

// WatchBytesUpdated is a free log subscription operation binding the contract event 0xee56af66250a5cbba377132a356dc403d520776e30969594927024c44af8440b.
//
// Solidity: event BytesUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchBytesUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractBytesUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "BytesUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractBytesUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "BytesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractIPFSHashDeletedIterator is returned from FilterIPFSHashDeleted and is used to iterate over the raw logs and unpacked data for IPFSHashDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractIPFSHashDeletedIterator struct {
	Event *PassportLogicContractIPFSHashDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractIPFSHashDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractIPFSHashDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractIPFSHashDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractIPFSHashDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractIPFSHashDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractIPFSHashDeleted represents a IPFSHashDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractIPFSHashDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterIPFSHashDeleted is a free log retrieval operation binding the contract event 0x140278d2322b9671bf293aea878e7717c46d5b7cd955e3e426ee67e01b901654.
//
// Solidity: event IPFSHashDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterIPFSHashDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractIPFSHashDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "IPFSHashDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractIPFSHashDeletedIterator{contract: _PassportLogicContract.contract, event: "IPFSHashDeleted", logs: logs, sub: sub}, nil
}

// WatchIPFSHashDeleted is a free log subscription operation binding the contract event 0x140278d2322b9671bf293aea878e7717c46d5b7cd955e3e426ee67e01b901654.
//
// Solidity: event IPFSHashDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchIPFSHashDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractIPFSHashDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "IPFSHashDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractIPFSHashDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "IPFSHashDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractIPFSHashUpdatedIterator is returned from FilterIPFSHashUpdated and is used to iterate over the raw logs and unpacked data for IPFSHashUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractIPFSHashUpdatedIterator struct {
	Event *PassportLogicContractIPFSHashUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractIPFSHashUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractIPFSHashUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractIPFSHashUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractIPFSHashUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractIPFSHashUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractIPFSHashUpdated represents a IPFSHashUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractIPFSHashUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterIPFSHashUpdated is a free log retrieval operation binding the contract event 0xdb23beee028623a85d5af1d247423ca471d20e499b131cd5e5c76277eaa2ad5b.
//
// Solidity: event IPFSHashUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterIPFSHashUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractIPFSHashUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "IPFSHashUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractIPFSHashUpdatedIterator{contract: _PassportLogicContract.contract, event: "IPFSHashUpdated", logs: logs, sub: sub}, nil
}

// WatchIPFSHashUpdated is a free log subscription operation binding the contract event 0xdb23beee028623a85d5af1d247423ca471d20e499b131cd5e5c76277eaa2ad5b.
//
// Solidity: event IPFSHashUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchIPFSHashUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractIPFSHashUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "IPFSHashUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractIPFSHashUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "IPFSHashUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractIntDeletedIterator is returned from FilterIntDeleted and is used to iterate over the raw logs and unpacked data for IntDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractIntDeletedIterator struct {
	Event *PassportLogicContractIntDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractIntDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractIntDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractIntDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractIntDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractIntDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractIntDeleted represents a IntDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractIntDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterIntDeleted is a free log retrieval operation binding the contract event 0x3c3ff48e02e407eb1e78310d11b5e3f9e735263a9cafc2bcf4aa981b8ecb32a5.
//
// Solidity: event IntDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterIntDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractIntDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "IntDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractIntDeletedIterator{contract: _PassportLogicContract.contract, event: "IntDeleted", logs: logs, sub: sub}, nil
}

// WatchIntDeleted is a free log subscription operation binding the contract event 0x3c3ff48e02e407eb1e78310d11b5e3f9e735263a9cafc2bcf4aa981b8ecb32a5.
//
// Solidity: event IntDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchIntDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractIntDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "IntDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractIntDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "IntDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractIntUpdatedIterator is returned from FilterIntUpdated and is used to iterate over the raw logs and unpacked data for IntUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractIntUpdatedIterator struct {
	Event *PassportLogicContractIntUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractIntUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractIntUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractIntUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractIntUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractIntUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractIntUpdated represents a IntUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractIntUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterIntUpdated is a free log retrieval operation binding the contract event 0xdb4ad6a3ed2bdacbae02da45a5bb54192cdb7d72648674d13e08d2fc4c45ac66.
//
// Solidity: event IntUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterIntUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractIntUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "IntUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractIntUpdatedIterator{contract: _PassportLogicContract.contract, event: "IntUpdated", logs: logs, sub: sub}, nil
}

// WatchIntUpdated is a free log subscription operation binding the contract event 0xdb4ad6a3ed2bdacbae02da45a5bb54192cdb7d72648674d13e08d2fc4c45ac66.
//
// Solidity: event IntUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchIntUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractIntUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "IntUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractIntUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "IntUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractOwnershipRenouncedIterator is returned from FilterOwnershipRenounced and is used to iterate over the raw logs and unpacked data for OwnershipRenounced events raised by the PassportLogicContract contract.
type PassportLogicContractOwnershipRenouncedIterator struct {
	Event *PassportLogicContractOwnershipRenounced // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractOwnershipRenouncedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractOwnershipRenounced)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractOwnershipRenounced)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractOwnershipRenouncedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractOwnershipRenouncedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractOwnershipRenounced represents a OwnershipRenounced event raised by the PassportLogicContract contract.
type PassportLogicContractOwnershipRenounced struct {
	PreviousOwner common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipRenounced is a free log retrieval operation binding the contract event 0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820.
//
// Solidity: event OwnershipRenounced(address indexed previousOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterOwnershipRenounced(opts *bind.FilterOpts, previousOwner []common.Address) (*PassportLogicContractOwnershipRenouncedIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "OwnershipRenounced", previousOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractOwnershipRenouncedIterator{contract: _PassportLogicContract.contract, event: "OwnershipRenounced", logs: logs, sub: sub}, nil
}

// WatchOwnershipRenounced is a free log subscription operation binding the contract event 0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820.
//
// Solidity: event OwnershipRenounced(address indexed previousOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchOwnershipRenounced(opts *bind.WatchOpts, sink chan<- *PassportLogicContractOwnershipRenounced, previousOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "OwnershipRenounced", previousOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractOwnershipRenounced)
				if err := _PassportLogicContract.contract.UnpackLog(event, "OwnershipRenounced", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the PassportLogicContract contract.
type PassportLogicContractOwnershipTransferredIterator struct {
	Event *PassportLogicContractOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractOwnershipTransferred represents a OwnershipTransferred event raised by the PassportLogicContract contract.
type PassportLogicContractOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*PassportLogicContractOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractOwnershipTransferredIterator{contract: _PassportLogicContract.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *PassportLogicContractOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractOwnershipTransferred)
				if err := _PassportLogicContract.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataExchangeAcceptedIterator is returned from FilterPrivateDataExchangeAccepted and is used to iterate over the raw logs and unpacked data for PrivateDataExchangeAccepted events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeAcceptedIterator struct {
	Event *PassportLogicContractPrivateDataExchangeAccepted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataExchangeAcceptedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataExchangeAccepted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataExchangeAccepted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataExchangeAcceptedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataExchangeAcceptedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataExchangeAccepted represents a PrivateDataExchangeAccepted event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeAccepted struct {
	ExchangeIdx   *big.Int
	DataRequester common.Address
	PassportOwner common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataExchangeAccepted is a free log retrieval operation binding the contract event 0x843dda373d0d243dce80a6cd203b9cbba8576d036c7eb937f9de36ebe6e8b023.
//
// Solidity: event PrivateDataExchangeAccepted(uint256 indexed exchangeIdx, address indexed dataRequester, address indexed passportOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataExchangeAccepted(opts *bind.FilterOpts, exchangeIdx []*big.Int, dataRequester []common.Address, passportOwner []common.Address) (*PassportLogicContractPrivateDataExchangeAcceptedIterator, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var dataRequesterRule []interface{}
	for _, dataRequesterItem := range dataRequester {
		dataRequesterRule = append(dataRequesterRule, dataRequesterItem)
	}
	var passportOwnerRule []interface{}
	for _, passportOwnerItem := range passportOwner {
		passportOwnerRule = append(passportOwnerRule, passportOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataExchangeAccepted", exchangeIdxRule, dataRequesterRule, passportOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataExchangeAcceptedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataExchangeAccepted", logs: logs, sub: sub}, nil
}

// WatchPrivateDataExchangeAccepted is a free log subscription operation binding the contract event 0x843dda373d0d243dce80a6cd203b9cbba8576d036c7eb937f9de36ebe6e8b023.
//
// Solidity: event PrivateDataExchangeAccepted(uint256 indexed exchangeIdx, address indexed dataRequester, address indexed passportOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataExchangeAccepted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataExchangeAccepted, exchangeIdx []*big.Int, dataRequester []common.Address, passportOwner []common.Address) (event.Subscription, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var dataRequesterRule []interface{}
	for _, dataRequesterItem := range dataRequester {
		dataRequesterRule = append(dataRequesterRule, dataRequesterItem)
	}
	var passportOwnerRule []interface{}
	for _, passportOwnerItem := range passportOwner {
		passportOwnerRule = append(passportOwnerRule, passportOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataExchangeAccepted", exchangeIdxRule, dataRequesterRule, passportOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataExchangeAccepted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataExchangeAccepted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataExchangeClosedIterator is returned from FilterPrivateDataExchangeClosed and is used to iterate over the raw logs and unpacked data for PrivateDataExchangeClosed events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeClosedIterator struct {
	Event *PassportLogicContractPrivateDataExchangeClosed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataExchangeClosedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataExchangeClosed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataExchangeClosed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataExchangeClosedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataExchangeClosedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataExchangeClosed represents a PrivateDataExchangeClosed event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeClosed struct {
	ExchangeIdx *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataExchangeClosed is a free log retrieval operation binding the contract event 0x5d1a7ae2ffda31cae15ed5129d32260ef2a270a21325f536f7954ed297e52c8e.
//
// Solidity: event PrivateDataExchangeClosed(uint256 indexed exchangeIdx)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataExchangeClosed(opts *bind.FilterOpts, exchangeIdx []*big.Int) (*PassportLogicContractPrivateDataExchangeClosedIterator, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataExchangeClosed", exchangeIdxRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataExchangeClosedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataExchangeClosed", logs: logs, sub: sub}, nil
}

// WatchPrivateDataExchangeClosed is a free log subscription operation binding the contract event 0x5d1a7ae2ffda31cae15ed5129d32260ef2a270a21325f536f7954ed297e52c8e.
//
// Solidity: event PrivateDataExchangeClosed(uint256 indexed exchangeIdx)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataExchangeClosed(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataExchangeClosed, exchangeIdx []*big.Int) (event.Subscription, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataExchangeClosed", exchangeIdxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataExchangeClosed)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataExchangeClosed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataExchangeDisputedIterator is returned from FilterPrivateDataExchangeDisputed and is used to iterate over the raw logs and unpacked data for PrivateDataExchangeDisputed events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeDisputedIterator struct {
	Event *PassportLogicContractPrivateDataExchangeDisputed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataExchangeDisputedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataExchangeDisputed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataExchangeDisputed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataExchangeDisputedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataExchangeDisputedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataExchangeDisputed represents a PrivateDataExchangeDisputed event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeDisputed struct {
	ExchangeIdx *big.Int
	Successful  bool
	Cheater     common.Address
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataExchangeDisputed is a free log retrieval operation binding the contract event 0x540941e0fc2370abde0bfa6ddbb49188469597e518416fa24327f39469c9b2ec.
//
// Solidity: event PrivateDataExchangeDisputed(uint256 indexed exchangeIdx, bool indexed successful, address indexed cheater)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataExchangeDisputed(opts *bind.FilterOpts, exchangeIdx []*big.Int, successful []bool, cheater []common.Address) (*PassportLogicContractPrivateDataExchangeDisputedIterator, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var successfulRule []interface{}
	for _, successfulItem := range successful {
		successfulRule = append(successfulRule, successfulItem)
	}
	var cheaterRule []interface{}
	for _, cheaterItem := range cheater {
		cheaterRule = append(cheaterRule, cheaterItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataExchangeDisputed", exchangeIdxRule, successfulRule, cheaterRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataExchangeDisputedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataExchangeDisputed", logs: logs, sub: sub}, nil
}

// WatchPrivateDataExchangeDisputed is a free log subscription operation binding the contract event 0x540941e0fc2370abde0bfa6ddbb49188469597e518416fa24327f39469c9b2ec.
//
// Solidity: event PrivateDataExchangeDisputed(uint256 indexed exchangeIdx, bool indexed successful, address indexed cheater)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataExchangeDisputed(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataExchangeDisputed, exchangeIdx []*big.Int, successful []bool, cheater []common.Address) (event.Subscription, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var successfulRule []interface{}
	for _, successfulItem := range successful {
		successfulRule = append(successfulRule, successfulItem)
	}
	var cheaterRule []interface{}
	for _, cheaterItem := range cheater {
		cheaterRule = append(cheaterRule, cheaterItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataExchangeDisputed", exchangeIdxRule, successfulRule, cheaterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataExchangeDisputed)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataExchangeDisputed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataExchangeProposedIterator is returned from FilterPrivateDataExchangeProposed and is used to iterate over the raw logs and unpacked data for PrivateDataExchangeProposed events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeProposedIterator struct {
	Event *PassportLogicContractPrivateDataExchangeProposed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataExchangeProposedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataExchangeProposed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataExchangeProposed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataExchangeProposedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataExchangeProposedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataExchangeProposed represents a PrivateDataExchangeProposed event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataExchangeProposed struct {
	ExchangeIdx   *big.Int
	DataRequester common.Address
	PassportOwner common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataExchangeProposed is a free log retrieval operation binding the contract event 0xabe53237e9ea366da7fa5507ac62db22bd446d6b66bcff4a6d6c1b11e9af1983.
//
// Solidity: event PrivateDataExchangeProposed(uint256 indexed exchangeIdx, address indexed dataRequester, address indexed passportOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataExchangeProposed(opts *bind.FilterOpts, exchangeIdx []*big.Int, dataRequester []common.Address, passportOwner []common.Address) (*PassportLogicContractPrivateDataExchangeProposedIterator, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var dataRequesterRule []interface{}
	for _, dataRequesterItem := range dataRequester {
		dataRequesterRule = append(dataRequesterRule, dataRequesterItem)
	}
	var passportOwnerRule []interface{}
	for _, passportOwnerItem := range passportOwner {
		passportOwnerRule = append(passportOwnerRule, passportOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataExchangeProposed", exchangeIdxRule, dataRequesterRule, passportOwnerRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataExchangeProposedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataExchangeProposed", logs: logs, sub: sub}, nil
}

// WatchPrivateDataExchangeProposed is a free log subscription operation binding the contract event 0xabe53237e9ea366da7fa5507ac62db22bd446d6b66bcff4a6d6c1b11e9af1983.
//
// Solidity: event PrivateDataExchangeProposed(uint256 indexed exchangeIdx, address indexed dataRequester, address indexed passportOwner)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataExchangeProposed(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataExchangeProposed, exchangeIdx []*big.Int, dataRequester []common.Address, passportOwner []common.Address) (event.Subscription, error) {

	var exchangeIdxRule []interface{}
	for _, exchangeIdxItem := range exchangeIdx {
		exchangeIdxRule = append(exchangeIdxRule, exchangeIdxItem)
	}
	var dataRequesterRule []interface{}
	for _, dataRequesterItem := range dataRequester {
		dataRequesterRule = append(dataRequesterRule, dataRequesterItem)
	}
	var passportOwnerRule []interface{}
	for _, passportOwnerItem := range passportOwner {
		passportOwnerRule = append(passportOwnerRule, passportOwnerItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataExchangeProposed", exchangeIdxRule, dataRequesterRule, passportOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataExchangeProposed)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataExchangeProposed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataHashesDeletedIterator is returned from FilterPrivateDataHashesDeleted and is used to iterate over the raw logs and unpacked data for PrivateDataHashesDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataHashesDeletedIterator struct {
	Event *PassportLogicContractPrivateDataHashesDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataHashesDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataHashesDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataHashesDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataHashesDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataHashesDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataHashesDeleted represents a PrivateDataHashesDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataHashesDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataHashesDeleted is a free log retrieval operation binding the contract event 0x9cad6db22e9f7e2a3441e18ef08567fa48da09796f593ded4222f0a315f98601.
//
// Solidity: event PrivateDataHashesDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataHashesDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractPrivateDataHashesDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataHashesDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataHashesDeletedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataHashesDeleted", logs: logs, sub: sub}, nil
}

// WatchPrivateDataHashesDeleted is a free log subscription operation binding the contract event 0x9cad6db22e9f7e2a3441e18ef08567fa48da09796f593ded4222f0a315f98601.
//
// Solidity: event PrivateDataHashesDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataHashesDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataHashesDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataHashesDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataHashesDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataHashesDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractPrivateDataHashesUpdatedIterator is returned from FilterPrivateDataHashesUpdated and is used to iterate over the raw logs and unpacked data for PrivateDataHashesUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataHashesUpdatedIterator struct {
	Event *PassportLogicContractPrivateDataHashesUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractPrivateDataHashesUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractPrivateDataHashesUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractPrivateDataHashesUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractPrivateDataHashesUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractPrivateDataHashesUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractPrivateDataHashesUpdated represents a PrivateDataHashesUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractPrivateDataHashesUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterPrivateDataHashesUpdated is a free log retrieval operation binding the contract event 0x0ed4013fbc8174781b18a7aa1cce7d589bc1fc3509941835787881ed2ab8b48e.
//
// Solidity: event PrivateDataHashesUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterPrivateDataHashesUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractPrivateDataHashesUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "PrivateDataHashesUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractPrivateDataHashesUpdatedIterator{contract: _PassportLogicContract.contract, event: "PrivateDataHashesUpdated", logs: logs, sub: sub}, nil
}

// WatchPrivateDataHashesUpdated is a free log subscription operation binding the contract event 0x0ed4013fbc8174781b18a7aa1cce7d589bc1fc3509941835787881ed2ab8b48e.
//
// Solidity: event PrivateDataHashesUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchPrivateDataHashesUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractPrivateDataHashesUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "PrivateDataHashesUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractPrivateDataHashesUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "PrivateDataHashesUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractStringDeletedIterator is returned from FilterStringDeleted and is used to iterate over the raw logs and unpacked data for StringDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractStringDeletedIterator struct {
	Event *PassportLogicContractStringDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractStringDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractStringDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractStringDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractStringDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractStringDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractStringDeleted represents a StringDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractStringDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterStringDeleted is a free log retrieval operation binding the contract event 0x491a0e0281af9fc88ff024cffc24db22eddd4f826cb30d84936592967dc9237c.
//
// Solidity: event StringDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterStringDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractStringDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "StringDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractStringDeletedIterator{contract: _PassportLogicContract.contract, event: "StringDeleted", logs: logs, sub: sub}, nil
}

// WatchStringDeleted is a free log subscription operation binding the contract event 0x491a0e0281af9fc88ff024cffc24db22eddd4f826cb30d84936592967dc9237c.
//
// Solidity: event StringDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchStringDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractStringDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "StringDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractStringDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "StringDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractStringUpdatedIterator is returned from FilterStringUpdated and is used to iterate over the raw logs and unpacked data for StringUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractStringUpdatedIterator struct {
	Event *PassportLogicContractStringUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractStringUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractStringUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractStringUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractStringUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractStringUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractStringUpdated represents a StringUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractStringUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterStringUpdated is a free log retrieval operation binding the contract event 0x43e6b7e3323b4598401023341c086c07c3ff5577f594b5aab9c065f2c3c9d590.
//
// Solidity: event StringUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterStringUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractStringUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "StringUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractStringUpdatedIterator{contract: _PassportLogicContract.contract, event: "StringUpdated", logs: logs, sub: sub}, nil
}

// WatchStringUpdated is a free log subscription operation binding the contract event 0x43e6b7e3323b4598401023341c086c07c3ff5577f594b5aab9c065f2c3c9d590.
//
// Solidity: event StringUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchStringUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractStringUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "StringUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractStringUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "StringUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractTxDataDeletedIterator is returned from FilterTxDataDeleted and is used to iterate over the raw logs and unpacked data for TxDataDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractTxDataDeletedIterator struct {
	Event *PassportLogicContractTxDataDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractTxDataDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractTxDataDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractTxDataDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractTxDataDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractTxDataDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractTxDataDeleted represents a TxDataDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractTxDataDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterTxDataDeleted is a free log retrieval operation binding the contract event 0x9b9532c8ba5879554dee7c3e9374bd26dbfb2f79cf7f247bcf90648fc81fc164.
//
// Solidity: event TxDataDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterTxDataDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractTxDataDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "TxDataDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractTxDataDeletedIterator{contract: _PassportLogicContract.contract, event: "TxDataDeleted", logs: logs, sub: sub}, nil
}

// WatchTxDataDeleted is a free log subscription operation binding the contract event 0x9b9532c8ba5879554dee7c3e9374bd26dbfb2f79cf7f247bcf90648fc81fc164.
//
// Solidity: event TxDataDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchTxDataDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractTxDataDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "TxDataDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractTxDataDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "TxDataDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractTxDataUpdatedIterator is returned from FilterTxDataUpdated and is used to iterate over the raw logs and unpacked data for TxDataUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractTxDataUpdatedIterator struct {
	Event *PassportLogicContractTxDataUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractTxDataUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractTxDataUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractTxDataUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractTxDataUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractTxDataUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractTxDataUpdated represents a TxDataUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractTxDataUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterTxDataUpdated is a free log retrieval operation binding the contract event 0xcbde9cd310365ff3de3ad9cb44ed688d8880c7b1d15df733a73880fb84d032de.
//
// Solidity: event TxDataUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterTxDataUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractTxDataUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "TxDataUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractTxDataUpdatedIterator{contract: _PassportLogicContract.contract, event: "TxDataUpdated", logs: logs, sub: sub}, nil
}

// WatchTxDataUpdated is a free log subscription operation binding the contract event 0xcbde9cd310365ff3de3ad9cb44ed688d8880c7b1d15df733a73880fb84d032de.
//
// Solidity: event TxDataUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchTxDataUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractTxDataUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "TxDataUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractTxDataUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "TxDataUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractUintDeletedIterator is returned from FilterUintDeleted and is used to iterate over the raw logs and unpacked data for UintDeleted events raised by the PassportLogicContract contract.
type PassportLogicContractUintDeletedIterator struct {
	Event *PassportLogicContractUintDeleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractUintDeletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractUintDeleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractUintDeleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractUintDeletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractUintDeletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractUintDeleted represents a UintDeleted event raised by the PassportLogicContract contract.
type PassportLogicContractUintDeleted struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterUintDeleted is a free log retrieval operation binding the contract event 0xd5f853f7aaba549b5a46be1de24cac4c20e716b4c603d24b2b0b7b5d97ca1c4d.
//
// Solidity: event UintDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterUintDeleted(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractUintDeletedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "UintDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractUintDeletedIterator{contract: _PassportLogicContract.contract, event: "UintDeleted", logs: logs, sub: sub}, nil
}

// WatchUintDeleted is a free log subscription operation binding the contract event 0xd5f853f7aaba549b5a46be1de24cac4c20e716b4c603d24b2b0b7b5d97ca1c4d.
//
// Solidity: event UintDeleted(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchUintDeleted(opts *bind.WatchOpts, sink chan<- *PassportLogicContractUintDeleted, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "UintDeleted", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractUintDeleted)
				if err := _PassportLogicContract.contract.UnpackLog(event, "UintDeleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractUintUpdatedIterator is returned from FilterUintUpdated and is used to iterate over the raw logs and unpacked data for UintUpdated events raised by the PassportLogicContract contract.
type PassportLogicContractUintUpdatedIterator struct {
	Event *PassportLogicContractUintUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractUintUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractUintUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractUintUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractUintUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractUintUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractUintUpdated represents a UintUpdated event raised by the PassportLogicContract contract.
type PassportLogicContractUintUpdated struct {
	FactProvider common.Address
	Key          [32]byte
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterUintUpdated is a free log retrieval operation binding the contract event 0xff76cb7634629f8d05011ab2a58380dfc0743157a70ba4173f866e113eca75c0.
//
// Solidity: event UintUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterUintUpdated(opts *bind.FilterOpts, factProvider []common.Address, key [][32]byte) (*PassportLogicContractUintUpdatedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "UintUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractUintUpdatedIterator{contract: _PassportLogicContract.contract, event: "UintUpdated", logs: logs, sub: sub}, nil
}

// WatchUintUpdated is a free log subscription operation binding the contract event 0xff76cb7634629f8d05011ab2a58380dfc0743157a70ba4173f866e113eca75c0.
//
// Solidity: event UintUpdated(address indexed factProvider, bytes32 indexed key)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchUintUpdated(opts *bind.WatchOpts, sink chan<- *PassportLogicContractUintUpdated, factProvider []common.Address, key [][32]byte) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}
	var keyRule []interface{}
	for _, keyItem := range key {
		keyRule = append(keyRule, keyItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "UintUpdated", factProviderRule, keyRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractUintUpdated)
				if err := _PassportLogicContract.contract.UnpackLog(event, "UintUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractWhitelistFactProviderAddedIterator is returned from FilterWhitelistFactProviderAdded and is used to iterate over the raw logs and unpacked data for WhitelistFactProviderAdded events raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistFactProviderAddedIterator struct {
	Event *PassportLogicContractWhitelistFactProviderAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractWhitelistFactProviderAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractWhitelistFactProviderAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractWhitelistFactProviderAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractWhitelistFactProviderAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractWhitelistFactProviderAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractWhitelistFactProviderAdded represents a WhitelistFactProviderAdded event raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistFactProviderAdded struct {
	FactProvider common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterWhitelistFactProviderAdded is a free log retrieval operation binding the contract event 0xff8ac5f0e9cdc8f7ffbbc29ab1301ee649cf01cf7a6a9265a2d90587612c4175.
//
// Solidity: event WhitelistFactProviderAdded(address indexed factProvider)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterWhitelistFactProviderAdded(opts *bind.FilterOpts, factProvider []common.Address) (*PassportLogicContractWhitelistFactProviderAddedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "WhitelistFactProviderAdded", factProviderRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractWhitelistFactProviderAddedIterator{contract: _PassportLogicContract.contract, event: "WhitelistFactProviderAdded", logs: logs, sub: sub}, nil
}

// WatchWhitelistFactProviderAdded is a free log subscription operation binding the contract event 0xff8ac5f0e9cdc8f7ffbbc29ab1301ee649cf01cf7a6a9265a2d90587612c4175.
//
// Solidity: event WhitelistFactProviderAdded(address indexed factProvider)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchWhitelistFactProviderAdded(opts *bind.WatchOpts, sink chan<- *PassportLogicContractWhitelistFactProviderAdded, factProvider []common.Address) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "WhitelistFactProviderAdded", factProviderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractWhitelistFactProviderAdded)
				if err := _PassportLogicContract.contract.UnpackLog(event, "WhitelistFactProviderAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractWhitelistFactProviderRemovedIterator is returned from FilterWhitelistFactProviderRemoved and is used to iterate over the raw logs and unpacked data for WhitelistFactProviderRemoved events raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistFactProviderRemovedIterator struct {
	Event *PassportLogicContractWhitelistFactProviderRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractWhitelistFactProviderRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractWhitelistFactProviderRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractWhitelistFactProviderRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractWhitelistFactProviderRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractWhitelistFactProviderRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractWhitelistFactProviderRemoved represents a WhitelistFactProviderRemoved event raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistFactProviderRemoved struct {
	FactProvider common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterWhitelistFactProviderRemoved is a free log retrieval operation binding the contract event 0x5bf47f016603dfff957e6086bd9a350212686e8f1d9208b3db47c5a3107c7878.
//
// Solidity: event WhitelistFactProviderRemoved(address indexed factProvider)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterWhitelistFactProviderRemoved(opts *bind.FilterOpts, factProvider []common.Address) (*PassportLogicContractWhitelistFactProviderRemovedIterator, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "WhitelistFactProviderRemoved", factProviderRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractWhitelistFactProviderRemovedIterator{contract: _PassportLogicContract.contract, event: "WhitelistFactProviderRemoved", logs: logs, sub: sub}, nil
}

// WatchWhitelistFactProviderRemoved is a free log subscription operation binding the contract event 0x5bf47f016603dfff957e6086bd9a350212686e8f1d9208b3db47c5a3107c7878.
//
// Solidity: event WhitelistFactProviderRemoved(address indexed factProvider)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchWhitelistFactProviderRemoved(opts *bind.WatchOpts, sink chan<- *PassportLogicContractWhitelistFactProviderRemoved, factProvider []common.Address) (event.Subscription, error) {

	var factProviderRule []interface{}
	for _, factProviderItem := range factProvider {
		factProviderRule = append(factProviderRule, factProviderItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "WhitelistFactProviderRemoved", factProviderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractWhitelistFactProviderRemoved)
				if err := _PassportLogicContract.contract.UnpackLog(event, "WhitelistFactProviderRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// PassportLogicContractWhitelistOnlyPermissionSetIterator is returned from FilterWhitelistOnlyPermissionSet and is used to iterate over the raw logs and unpacked data for WhitelistOnlyPermissionSet events raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistOnlyPermissionSetIterator struct {
	Event *PassportLogicContractWhitelistOnlyPermissionSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *PassportLogicContractWhitelistOnlyPermissionSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(PassportLogicContractWhitelistOnlyPermissionSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(PassportLogicContractWhitelistOnlyPermissionSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *PassportLogicContractWhitelistOnlyPermissionSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *PassportLogicContractWhitelistOnlyPermissionSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// PassportLogicContractWhitelistOnlyPermissionSet represents a WhitelistOnlyPermissionSet event raised by the PassportLogicContract contract.
type PassportLogicContractWhitelistOnlyPermissionSet struct {
	OnlyWhitelist bool
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterWhitelistOnlyPermissionSet is a free log retrieval operation binding the contract event 0x6e1eb3fa845047cf9d5fd1deb1b7770b4e26163dd4d88cefb14fe7964a700595.
//
// Solidity: event WhitelistOnlyPermissionSet(bool indexed onlyWhitelist)
func (_PassportLogicContract *PassportLogicContractFilterer) FilterWhitelistOnlyPermissionSet(opts *bind.FilterOpts, onlyWhitelist []bool) (*PassportLogicContractWhitelistOnlyPermissionSetIterator, error) {

	var onlyWhitelistRule []interface{}
	for _, onlyWhitelistItem := range onlyWhitelist {
		onlyWhitelistRule = append(onlyWhitelistRule, onlyWhitelistItem)
	}

	logs, sub, err := _PassportLogicContract.contract.FilterLogs(opts, "WhitelistOnlyPermissionSet", onlyWhitelistRule)
	if err != nil {
		return nil, err
	}
	return &PassportLogicContractWhitelistOnlyPermissionSetIterator{contract: _PassportLogicContract.contract, event: "WhitelistOnlyPermissionSet", logs: logs, sub: sub}, nil
}

// WatchWhitelistOnlyPermissionSet is a free log subscription operation binding the contract event 0x6e1eb3fa845047cf9d5fd1deb1b7770b4e26163dd4d88cefb14fe7964a700595.
//
// Solidity: event WhitelistOnlyPermissionSet(bool indexed onlyWhitelist)
func (_PassportLogicContract *PassportLogicContractFilterer) WatchWhitelistOnlyPermissionSet(opts *bind.WatchOpts, sink chan<- *PassportLogicContractWhitelistOnlyPermissionSet, onlyWhitelist []bool) (event.Subscription, error) {

	var onlyWhitelistRule []interface{}
	for _, onlyWhitelistItem := range onlyWhitelist {
		onlyWhitelistRule = append(onlyWhitelistRule, onlyWhitelistItem)
	}

	logs, sub, err := _PassportLogicContract.contract.WatchLogs(opts, "WhitelistOnlyPermissionSet", onlyWhitelistRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(PassportLogicContractWhitelistOnlyPermissionSet)
				if err := _PassportLogicContract.contract.UnpackLog(event, "WhitelistOnlyPermissionSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
